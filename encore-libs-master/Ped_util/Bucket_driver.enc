module Bucket_driver
import Agent_passive
import Global_funs
import SDL.SDL_Main
import Ped_util.UI
def bucket(agents: [Agent],ui:bool) : void {
     let
         i = 0
         drivers= new [Bucket_driver]( |agents| )
         j = 0
         sdl_main = if ui then make_UI() else null : SDL_Main
         manager = new Bucket_manager(40000,ui,sdl_main)
     in
     {
         for a in agents {
             drivers[i]=new Bucket_driver(a,|agents|,manager);
             i=i+1;
         };
         i=0;
         for a in drivers{
             for b in drivers {
                 unless (a==b) then {
                 a!link(b);
                 }
             }
         };
        --print("starting!\n");
         manager.start(drivers);
     }
 }
class Bucket_manager {
    i : int
    wait : int
    dr : [Bucket_driver]
    ui : bool
    sdl_main : SDL_Main
    def init(iterations:int,ui:bool,sdl_main:SDL_Main) : void {
        this.i=iterations;
        this.ui=ui;
        this.sdl_main=sdl_main;
    }
    def start(drivers:[Bucket_driver]) : void {
        this.dr=drivers;
        this!move();
    }
    def move() : void {
        this.i=this.i-1;
        if this.i<1 then { () } else {
            if(this.i%10000==0) then print(this.i);
            if(this.ui) then {
                let positions = new [(int,int)](|this.dr|);
                    for w in [0..(|this.dr|-1)] {
                        positions[w]=get((this.dr[w]).get_pos());
                    };
                    show(positions,this.sdl_main)
                };
            this.wait=(|this.dr|);
            for a in this.dr { a!move() }
        }
    }
    def reply() : void {
        this.wait=this.wait-1;
        if this.wait==0 then this.move()
    }
}
class Bucket_driver {
    agent : Agent
    responses_left : [int]
    full : [bool]
    target_x : [int]
    target_y : [int]
    moved : bool
    link_index : int
    links : [Bucket_driver]
    manager : Bucket_manager
    def get_pos() : (int,int) {
        this.agent.pos();
    }
    def init(a:Agent,size:int,manager:Bucket_manager) : void {
        this.agent=a;
        this.links=new [Bucket_driver](size-1);
        this.link_index=0;
        this.manager=manager;
        --2 is the largest possible number of desired positions for an agent
        this.target_x = new [int](2);
        this.target_y = new [int](2);
        this.full = new [bool](2);
        this.responses_left = new [int](2);
    }
    def link(a:Bucket_driver) : void {
        this.links[this.link_index]=a;
        this.link_index=this.link_index+1;
    }
    def move() : void {
        let i=0;
        let temp = this.agent.next();
        this.moved=false;
        for desired in temp {
            this.responses_left[i]= this.link_index;
            match desired with (x,y) => {
                this.target_x[i]=x;
                this.target_y[i]=y;
            };
            this.full[i]=false;
            for a in this.links {
                a!request(this,i);
            };
            i=i+1;
        };
        ()
    }
    def request(d:Bucket_driver,reply_index:int) : void {
        d!reply(reply_index,this.agent.x,this.agent.y)
    }
    def reply(index:int,x:int,y:int) : void {
        this.responses_left[index]=this.responses_left[index]-1;
        if( (x==(this.target_x)[index]) and (y==(this.target_y)[index]) ) then {
            this.full[index]=true;
        };
        --print("repyling {} {}\n",this.responses_left[index],index);
        if(this.responses_left[index]==0) then {
            if (((this.full)[index]==false) and (this.moved==false)) then {
                this.agent.move_int(this.target_x[index],this.target_y[index]);
                this.moved=true;
            };
            --check if last expected message
            let sum=0;
            for a in this.responses_left {
                --print("{}\n",a);
                sum=sum+a;
            };
            --print("replies left {}\n",sum);
            if sum==0 then {this.manager!reply()}; --if true tell manager done()
        }
    }
}

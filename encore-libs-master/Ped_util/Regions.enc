
module Regions
import Agent_passive
import Global_funs
import SDL.SDL_Main
import Ped_util.UI
import Quad_tree

--TODO FIX DOUBLE MOVE BUG!!!

def regions(agents: [Agent],ui:bool,boxes:int) : void {
     var sdl_main = if ui then make_UI() else null : SDL_Main;
     var box = new Tiling_box(agents,boxes);
     print(("Encore regions",|agents|));
     box!move(ui,sdl_main,10000,clock()); --40000
 }
class Tiling_box {
    boxes : [Box]
    futures : [Fut bool]
    def init(agents:[Agent],n:int) : void {
        match find_extreme(agents) with
            (xmax,ymax,xmin,ymin) => {
                val dx= (xmax-xmin)/n;
                val dy= (ymax-ymin)/n;
                --print((xmax,ymax));
                this.boxes = new [Box](n*n);
                this.futures= new [Fut bool](|this.boxes|);
                var x = xmin;
                var y = ymin;
                var i = 0;
                var win = true;
                for xindex in [0..n-1] { --creating and linking boxes
                    for yindex in [0..n-2] {
                        --print("new\n");
                        this.boxes[i]= new Box( ((x+dx-1),(y+dy-1)),(x,y) );
                        if(yindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[i-1]);
                            --print("link {} {} {}\n",i,i-1,win);
                        };
                        if(xindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[i-n]);
                            --print("link {} {} {}\n",i,i-n,win);
                        };
                        if(xindex!=0 and yindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[(i-n)+1]);
                            win = win and link(this.boxes[i],this.boxes[(i-n)-1]);
                            ();
                        };
                        i=i+1;
                        y=y+dy;
                    };
                    --print("big\n");
                    this.boxes[i]= new Box( (x+dx-1,ymax),(x,y) ); -- last box might be bigger, due to division rounding
                    if(xindex!=0) then {
                        win = win and link(this.boxes[i],this.boxes[i-n]);
                        win = win and link(this.boxes[i],this.boxes[(i-n)-1]);
                    };
                    win = win and link(this.boxes[i],this.boxes[i-1]);
                    --print("link {} {} {}\n",i,i-1,win);
                    i=i+1;
                    x=x+dx;
                    y=ymin;
                };--creating and linking boxes
                for yindex in [0..n-2] {
                        --print("new\n");
                        this.boxes[i]= new Box( (xmax,(y+dy-1)),(x,y) );
                        if(yindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[i-1]);
                            win = win and link(this.boxes[i],this.boxes[(i-n)-1]);
                        };
                            win = win and link(this.boxes[i],this.boxes[(i-n)+1]);
                            win = win and link(this.boxes[i],this.boxes[i-n]);
                        i=i+1;
                        y=y+dy;
                    };
                    --print("big\n");
                    this.boxes[i]= new Box( (xmax,ymax),(x,y) ); -- last box might be bigger, due to division rounding
                    win = win and link(this.boxes[i],this.boxes[i-n]);
                    win = win and link(this.boxes[i],this.boxes[i-1]);
                    win = win and link(this.boxes[i],this.boxes[(i-n)-1]);
                    --win = win and link(this.boxes[i],this.boxes[i-n-1]);
                unless win then print("WIN IS BAD!\n");
                --print(win); -- if win is false something is of with linking/creation
                for a in agents { --this is very slow, try sending each agent to one box at the time until it find one that fits
                    for b in this.boxes {
                        if( get(b.add(a)) ) then {
                            embed void { break; } end;
                        };
                    };
                };
    }}
    def move (ui:bool,sdl_main:SDL_Main,i:int,start_time:int) : void {
        --print("step {} GO!\n",i);
        for id in [0..|this.boxes|-1] {
            this.futures[id]=(this.boxes[id]).move();
        };
        for f in this.futures {
            get(f);
        };
        --print("done_wait\n");
        --if(i%1000==0) then {print(time); time=0};
        if(ui) then show(this.agents(),sdl_main);
        if(i>1) then this!move(ui,sdl_main,i-1,start_time) else {printtime(clock()-start_time);}
        --print(|this.agents()|);
        }
    def agents() : [(int,int)] {
        val temp = new [[(int,int)]](|this.boxes|);
            for i in [0..|this.boxes|-1] {
                temp[i]=get(((this.boxes)[i]).agents());
            };
            flatten(temp)
        }
}

--single threaded 2D space container
--contains all Agents in a given 2D region of space
--assumess cordnate system where Y is height and X is with, so increasing X means further to the right
class Box {
-- min and max are inclusive
-- max is the greatest X value and the greatest Y value box contains
-- min is the smalles X and Y values
 xmax : int
 ymax : int
 xmin : int
 ymin : int
 up : Box
 down : Box
 left : Box
 right : Box
 top_right : Box
 top_left : Box
 bottom_left : Box
 bottom_right : Box

 matrix : Quad_tree --Best name for this data structure ever
 agents : Item
 last : Item
 newcommers : Item
 to_early : Item
 ttl : int
 size : int
 moving : bool

def init(in_max:(int,int), in_min:(int,int) ) : void {
    this.matrix= new Quad_tree(in_max,in_min);
    match in_max with (x,y) => {this.xmax=x;this.ymax=y};
    match in_min with (x,y) => {this.xmin=x;this.ymin=y};
    this.ttl=10001;
    this.size=0;
    this.moving=false;
    }
--getters for borders
def min() : (int,int) { (this.xmin,this.ymin) }
def max() : (int,int) { (this.xmax,this.ymax) }

--check_ methods for invariant checking, only used when debuging
def check_newcommers() : void {
    var cur = this.newcommers;
    var i = 1;
    print("Is newcommers related to last? ");
    while (cur!=this.last) { if(cur.a==null) then {print("GHOST IN THE CHAIN\n"); while true { () }; }; cur=cur.next; i=i+1;};
    print(" Yes {}\n",i);
}
def check_channeling() : void {
    var cur= this.agents;
    var i=0;
    while cur!=null { i=i+1; cur=cur.next; };
    var j=this.matrix.size();
    if( i > j ) then print("more linked list agents ");
    if( i < j ) then print("more matrix agents ");
    if( i != j ) then {
            print((i,j,this.size));
            cur=this.agents;
            i=0;
            while cur!=null {
                if (this.matrix.get_val(cur.a.x, cur.a.y) == false) then {print("AGENT'S pos not in MATRIX {} {} {}\n", cur.a.hash_code, i,(this.xmax,this.ymax)); };
                i=i+1;
                cur=cur.next;
            };
            while true { () };};
}
-- SLOW BUT ONLY USED BY UI, returns pos of all agents
def agents() : [(int,int)] {
    --this.merge();
    if(this.agents==null) then { new [(int,int)](0); } else {
    var cur= this.agents;
    var i=0;
    while cur!=null { i=i+1; cur=cur.next; };
    var ret= new [(int,int)](i);
    cur=this.agents;
    i=0;
    while cur!=null {
        ret[i]=cur.a.pos();
        --print(i);
        i=i+1;
        cur=cur.next
        };
    ret
    }}
 --adds new agents to newcommers linked list
def add(a:Agent) : bool {
    if a.x>this.xmax or a.x<this.xmin or a.y>this.ymax or a.y<this.ymin then false else {
        this.add_internal(a);
    }
}
    --recives a Agent from another box
def external_move(a:Agent, x:int,y:int ) : bool {
    --unless this.ttl==a.ttl+2 or this.ttl==a.ttl+1 then {print(("out_of_sync",this.ttl,a.ttl, a.hash_code)); while true { () } };
    --false;
    if x>this.xmax or x<this.xmin or y>this.ymax or y<this.ymin then { false } else { -- robustness for 
    if(this.matrix.get_val(x,y)==true ) then { false } else {
        a.move_int(x,y);
        this.add_internal(a);
        };
    }}
def add_internal(a:Agent) : bool {
    if(this.matrix.get_val(a.x,a.y)==true) then {print("AGENTS IN TOP OF eachother\n"); while true { () }; true } else {
        this.matrix.set(a.x,a.y); --add to collison matrix
        if(this.newcommers == null) then {
            this.newcommers=new Item(a);
        } else if (this.last == null) then {
            this.last=new Item(a);
            this.newcommers.append(this.last);
        } else {
            var new_wraper = new Item(a);
            this.last.append(new_wraper);
            this.last=new_wraper;
        };
        this.size=this.size+1;
        true;
    }
}
--if the arguement shares a border or corner with this box, it's added tas a nejbor and returns true
--otherwise returns false
def link(a:Box) : bool {
    var c=a.max();
    var d=a.min();
    await(c);
    await(d);
    match (this.xmax,this.ymax,this.xmin,this.ymin,get(c),get(d)) with
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) => {
            var top = (y_max_1+1 == y_min_2);
            var bottom = (y_min_1-1 == y_max_2);
            var right = (x_max_1+1 == x_min_2);
            var left = (x_min_1-1 == x_max_2);
            if not(left or right or top or bottom) then false else {
                if top then {
                    if right then {
                        if this.top_right==null then {this.top_right=a;true} else false
                    } else if left then {
                        if this.top_left==null then {this.top_left=a;true} else false
                    } else {
                        if this.up==null then {this.up=a;true} else false
                    }
                } else
                if bottom then {
                    if right then {
                        if this.bottom_right==null then {this.bottom_right=a;true} else false
                    } else if left then {
                        if this.bottom_left==null then {this.bottom_left=a;true} else false
                    } else {
                        if this.down==null then {this.down=a;true} else false
                    }
                } else if right then { if this.right==null then {this.right=a; true} else false }
                else {if this.left==null then {this.left=a; true} else false }
            }
        }
    }
def merge() : void {
        if(this.newcommers!=null) then {
            --this.check_newcommers();
            if(this.agents!=null) then {
                if(this.last==null) then {
                    --unless (this.newcommers.next==null and this.newcommers.prev==null) then { print("ONE AGENT NOT REALLY ALONE!\n"); while true { () }; };
                    --print("one agent arrived {} {}\n",this.newcommers.a.hash_code,(this.xmax,this.ymax) );
                    this.newcommers.append(this.agents);
                }
                else
                    {this.last.append(this.agents);};
                this.agents=this.newcommers;
            } else { this.agents=this.newcommers;};
            this.newcommers=null;
            this.last=null;
            --print("MERING\n");
        };
        --this.check_channeling();
    }
 --moves all agents in the box once
 --returns true
def move() : bool {
        --if this.moving==true then { print("2 MOVE MESSAGES AT THE SAME TIME\n"); };
        this.ttl=this.ttl-1;
        --unless step_nr==this.ttl then { print( (step_nr,this.ttl,"ttl!=step_nr") ); while true { () } };
        --print(("moving",step_nr,this.xmax,this.ymax));
        this.merge();
        var parent = this.agents;
        var a = this.agents;
       while a!=null {
            --unless (a.a.ttl==step_nr or a.a.ttl==step_nr-1) then {print(this.ttl,a.a.ttl,a.a.hash_code); while true { () } };
            if ((a.a.ttl)==this.ttl) then { -- removes unlikely case when an agent is moved twice
                a.a.ttl=a.a.ttl-1;
                var desired = a.a.next();
                var i = 0;
                var nejbor = null:Fut bool;
                var moved = false;
                var x2 =0;
                var y2 =0;
            while(i < |desired| and moved == false) {
                    match desired[i] with (x,y) => {
                        nejbor=null;
                        let
                            up = y>this.ymax
                            down = y<this.ymin
                            right = x>this.xmax
                            left = x<this.xmin
                            border = { --find which border is crossed, if any
                                    if up then {
                                        if right then {
                                            this.top_right
                                        } else if left then {
                                            this.top_left
                                        } else {
                                            this.up
                                        }
                                    } else if down then {
                                        if right then {
                                            this.bottom_right
                                        } else if left then {
                                            this.bottom_left
                                        } else {
                                            this.down
                                        }
                                    } else if left then {this.left} else if right then {this.right} else {null : Box}
                            }
                        in {
                        if up or down or left or right then { --if outside of the box
                            if(border==null) then {
                                --print("collision with edge of simulation, {}\n", (x,y));
                                nejbor=mk_Future(false)
                            } else {
                                --print("{} {} hash: {}\n",(a.a.x,a.a.y),desired[i],a.a.hash_code);
                                x2=a.a.x; y2=a.a.y;
                                nejbor=border.external_move(a.a,x,y);
                            }
                        };
                        if nejbor==null then {
                            --local collision detection
                            if this.matrix.get_val(x,y)==false then {
                                --print(this.matrix.get_val(a.a.x,a.a.y));
                                unless this.matrix.remove(a.a.x,a.a.y) then { print("remove failed\n"); while true { () } }; --remove from old pos
                                this.matrix.set(x,y); --add to new pos
                                a.a.move_int(x,y); --move
                                moved=true;
                                --print("moved\n");
                            }
                        } else {
                            await(nejbor);
                            if get(nejbor) then { --if left this box
                                this.size=this.size-1;

                                unless this.matrix.remove(x2,y2) then { print("remove failed 2\n"); while true { () } }; --remove from old pos
                                moved=true;
                                if a==this.agents then {this.agents=a.next;};
                                a.delete();
                            }
                        };
                            i=i+1;
                        }}}}; --else {print("timetraveler detected {} {} {}\n", a.a.hash_code,a.a.ttl,this.ttl);};
                        a=a.next;
            };
          this.moving=false;
          true;
         }
}

--UTIL CLASSES FOR Box
    passive class Item {
        a : Agent
        next : Item
        prev : Item
        def init(a:Agent) : void {this.a=a;}
        def delete() : void {
            if this.next==null and this.prev==null then
            { () }
            else if this.prev==null then {
                this.next.prev=null;
            } else if this.next==null then {
                this.prev.next=null;
            } else {
                this.next.prev=this.prev;
                this.prev.next=this.next;
            };
            this.a=null;
        }
        def append(next:Item) : void {
            this.next=next;
            if(next!=null) then {
            next.prev=this;
        }}
    }

def link(a:Box,b:Box) : bool {
    val aa=a.link(b);
    val bb=b.link(a);
    val aaa = get(aa);
    val bbb = get(bb);
    unless aaa==bbb then print("ONE_WAY_LINK\n");
    aaa
}

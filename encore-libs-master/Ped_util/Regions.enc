
module Regions
import Agent_passive
import Global_funs
import SDL.SDL_Main
import Ped_util.UI
import Quad_tree


--TODO FIX DOUBLE MOVE BUG!!!

def regions(agents: [Agent],ui:bool,boxes:int) : void {
     var sdl_main = if ui then make_UI() else null : SDL_Main;
     var box = new Tiling_box(agents,boxes);
     --print(|agents|);
     box!move(ui,sdl_main,10000,clock()); --40000
 }
class Tiling_box {
    boxes : [Box]
    futures : [Fut bool]
    def init(agents:[Agent],n:int) : void {
        match find_extreme(agents) with
            (xmax,ymax,xmin,ymin) => {
                val dx= (xmax-xmin)/n;
                val dy= (ymax-ymin)/n;
                --print((xmax,ymax));
                this.boxes = new [Box](n*n);
                this.futures= new [Fut bool](|this.boxes|);
                var x = xmin;
                var y = ymin;
                var i = 0;
                var win = true;
                for xindex in [0..n-1] { --creating and linking boxes
                    for yindex in [0..n-2] {
                        --print("new\n");
                        this.boxes[i]= new Box( ((x+dx-1),(y+dy-1)),(x,y) );
                        if(yindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[i-1]);
                            --print("link {} {} {}\n",i,i-1,win);
                        };
                        if(xindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[i-n]);
                            --print("link {} {} {}\n",i,i-n,win);
                        };
                        i=i+1;
                        y=y+dy;
                    };
                    --print("big\n");
                    this.boxes[i]= new Box( (x+dx-1,ymax),(x,y) ); -- last box might be bigger, due to division rounding
                    if(xindex!=0) then {
                        win = win and link(this.boxes[i],this.boxes[i-n]);
                        --print("link {} {} {}\n",i,i-n,win);
                    };
                    win = win and link(this.boxes[i],this.boxes[i-1]);
                    --print("link {} {} {}\n",i,i-1,win);
                    i=i+1;
                    x=x+dx;
                    y=ymin;
                };--creating and linking boxes
                for yindex in [0..n-2] {
                        --print("new\n");
                        this.boxes[i]= new Box( (xmax,(y+dy-1)),(x,y) );
                        if(yindex!=0) then {
                            win = win and link(this.boxes[i],this.boxes[i-1]);
                            --print("link {} {} {}\n",i,i-1,win);
                        };
                            win = win and link(this.boxes[i],this.boxes[i-n]);
                        i=i+1;
                        y=y+dy;
                    };
                    --print("big\n");
                    this.boxes[i]= new Box( (xmax,ymax),(x,y) ); -- last box might be bigger, due to division rounding
                    win = win and link(this.boxes[i],this.boxes[i-n]);
                    win = win and link(this.boxes[i],this.boxes[i-1]);
                unless win then print("WIN IS BAD!\n");
                --print(win); -- if win is false something is of with linking/creation
                for a in agents { --this is very slow, try sending each agent to one box at the time until it find one that fits
                    for b in this.boxes {
                        if( get(b.add(a)) ) then {
                            embed void { break; } end;
                        };
                    };
                };
    }}
    def move (ui:bool,sdl_main:SDL_Main,i:int,start_time:int) : void {
        for i in [0..|this.boxes|-1] {
            this.futures[i]=(this.boxes[i]).move();
        };
        for f in this.futures {
            await(f);
        };
        --print("done_wait\n");
        --if(i%1000==0) then {print(time); time=0};
        if(ui) then show(this.agents(),sdl_main);
        if(i>1) then this!move(ui,sdl_main,i-1,start_time) else {printtime(clock()-start_time);}
        --print(|this.agents()|);
        }
    def agents() : [(int,int)] {
        val temp = new [[(int,int)]](|this.boxes|);
            for i in [0..|this.boxes|-1] {
                temp[i]=get(((this.boxes)[i]).agents());
            };
            flatten(temp)
        }
}

--multi threaded 2D space container
class Multi_box { --container of 4 boxes
    --max x and y cords
    max : (int,int)
    --min x and y cords
    min : (int,int)
    --4 sub-boxes, together covering all the space in Multi_box

    top_right : Box
    bottom_right : Box
    top_left : Box
    bottom_left : Box

    def init(agents:[Agent]) : void {
        var dx=0;
        var dy=0;
        --find global xmax, xmin, and ymin, use to create boundries for the 2D space.
        --looks at both starting positions and waypoints
        match find_extreme(agents) with
            (xmax,ymax,xmin,ymin) => {this.max=(xmax,ymax);
                                      this.min=(xmin,ymin);
                                      dx=xmax-xmin;
                                      dy=ymax-ymin;
                                      --if(dx%2==0) then
                                        dx=dx/2;
                                      --else
                                        dy=dy/2;
                                      --print("{} {} {}\n",this.max,this.min,(xmax-dx,ymax-dy));
                                      this.top_right=new Box(this.max,(xmax-dx+1,ymax-dy+1 ) );
                                      this.bottom_left=new Box( (xmax-dx,ymax-dy),this.min);
                                      this.top_left= new Box( (xmax-dx,ymax),(xmin,ymax-dy+1) );
                                      this.bottom_right=new Box( (xmax,ymax-dy),(xmax-dx+1,ymin) );
                                      --this.toplevel=new Box(  );
                                      };
        --put each agent into exactly one box
        for a in agents {
            if( get(this.top_right.add(a))) then { () }
            else if( get(this.top_left.add(a))) then { () }
            else if( get(this.bottom_right.add(a))) then { () }
            else if( get(this.bottom_left.add(a))) then { () }
            else { print("{} didn't get in \n", a.pos());}
        };
        var win=true;
        --LINKING BOXES, to allow them to pass agents between eachother
        win=win and get (this.top_right.link(this.top_left));
        win=win and get (this.top_right.link(this.bottom_right));
        win=win and get (this.top_left.link(this.top_right));
        win=win and get (this.top_left.link(this.bottom_left));
        win=win and get (this.bottom_left.link(this.bottom_right));
        win=win and get (this.bottom_left.link(this.top_left));
        win=win and get (this.bottom_right.link(this.top_right));
        win=win and get (this.bottom_right.link(this.bottom_left));
        --print("WIN={}\n",win);
    }
    --get corners of box
    def max() : (int,int) {this.max}
    def min() : (int,int) {this.min}
    def center() : (int,int) {get(this.bottom_left.max()) }
    --moves all internal agents on step, returns true if any agents tried to move
    def move (ui:bool,sdl_main:SDL_Main,i:int) : void {
        --debug check
        --print("multi_move\n");
        print("derp");
        let
        a = this.top_right.move()
        b = this.top_left.move()
        c = this.bottom_right.move()
        d = this.bottom_left.move()
        in {
        --print("await\n");
        await(a);
        await(b);
        await(c);
        await(d);
        --print("done_wait\n");
        if(ui) then show(this.agents(),sdl_main);
        if(i>1) then this!move(ui,sdl_main,i-1);
        if(i%10 == 0) then print(i);
        --print(|this.agents()|);
        }
    }
    def agents() : [(int,int)] {flatten([get(this.top_right.agents()),
                             get(this.top_left.agents()),
                             get(this.bottom_right.agents()),
                             get(this.bottom_left.agents())]) }

}

--single threaded 2D space container
--contains all Agents in a given 2D region of space
--assumess cordnate system where Y is height and X is with, so increasing X means further to the right
class Box {
-- min and max are inclusive
-- max is the greatest X value and the greatest Y value box contains
-- min is the smalles X and Y values
 xmax : int
 ymax : int
 xmin : int
 ymin : int
 up : Box
 down : Box
 left : Box
 right : Box
 matrix : Quad_tree --Best name for this data structure ever
 agents : Item
 last : Item
 newcommers : Item
def init(in_max:(int,int), in_min:(int,int) ) : void {
    this.matrix= new Quad_tree(in_max,in_min);
    match in_max with (x,y) => {this.xmax=x;this.ymax=y};
    match in_min with (x,y) => {this.xmin=x;this.ymin=y};
    --print("done\n");
    }
--getters for borders
def min() : (int,int) { (this.xmin,this.ymin) }
def max() : (int,int) { (this.xmax,this.ymax) }
-- SLOW BUT ONLY USED BY UI
def agents() : [(int,int)] {
    this.merge();
    --print("merge done\n");
    if(this.agents==null) then {
    --    var j=0;
    --    for a in this.matrix.locks {if a==true then j=j+1;};
    --    print((0,j));
    --    if( j != 0 ) then { while true { () }; };
        new [(int,int)](0); } else {
    --print("allocating agents\n");
    var cur= this.agents;
    var i=0;
    while cur!=null { i=i+1; cur=cur.next; };
    var j=this.matrix.size();
    if( i != j ) then { print((i,j)); while true { () }; };
    var ret= new [(int,int)](i);
    cur=this.agents;
    i=0;
    while cur!=null {
        ret[i]=cur.a.pos();
        --print(i);
        i=i+1;
        cur=cur.next
        };
    ret
    }}
 --adds new agents to newcommers linked list
def add(a:Agent) : bool {
    if a.x>this.xmax or a.x<this.xmin or a.y>this.ymax or a.y<this.ymin then false else {
        if(this.matrix.get_val(a.x,a.y)==true) then {print("#"); true} else { --print("agents stacked on eachother\n");
        this.matrix.set(a.x,a.y,true); --add to collison matrix
    if(this.newcommers == null) then {this.newcommers=new Item(a); this.last=this.newcommers;} else {
        this.last.next=new Item(a);
        this.last=this.last.next;
    };
    true;
    }}
}
--if the arguements shares a border with this box, it's added to the apropriate edge and returns true
--otherwise returns false
def link(a:Box) : bool {
    var c=a.max();
    var d=a.min();
    await(c);
    await(d);
    match (this.xmax,this.ymax,this.xmin,this.ymin,get(c),get(d)) with
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_1+1) == x_min_2) and (y_max_1==y_max_2) and (this.right==null) => {this.right=a;--print("right\n");
true }
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_1+1) == y_min_2) and (x_max_1==x_max_2) and (this.up==null) => {this.up=a;   --print("up\n");
true }
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_2+1) == x_min_1) and (y_max_1==y_max_2) and (this.left==null) => {this.left=a; --print("left\n");
true }
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_2+1) == y_min_1) and (x_max_1==x_max_2) and (this.down==null) => {this.down=a; --print("down\n");
true }
        _ => { false }
    }
def default_link(a:Box) : void {
        this.up=a;
        this.down=a;
        this.left=a;
        this.right=a;
    }
def merge() : void {
        if(this.newcommers!=null) then {
            --print((this.last.next,this.last.a,this.agents));
            this.last.next=this.agents; --append current agents to new agents list
            this.agents=this.newcommers; -- replace current agents with new agents list
            this.newcommers=null;
            --this.last=null;
        }
    }
 --moves all agents in the box once
 --returns true
def move() : bool {
        --print("serial_move\n");
        this.merge();
        var parent = this.agents;
        var a = this.agents;
       while a!=null {
            --print(a.a.next());
                var desired = a.a.next();
                var i = 0;
                var nejbor = null:Fut bool;
                var moved = false;
                var x2 =0;
                var y2 =0;
            --print("+");
            while( i < |desired| and moved == false) {
                    match desired[i] with (x,y) => {
                        --print( ("go",desired[i],a.a.pos()) );
                        nejbor=null;
                        if x>this.xmax then { x2=a.a.x; y2=a.a.y; if(this.right==null) then {nejbor=mk_Future(false)} else {nejbor=this.right.external_move(a.a,x,y)}};
                        if y>this.ymax then { x2=a.a.x; y2=a.a.y; if(this.up==null) then {nejbor=mk_Future(false)} else {nejbor=this.up.external_move(a.a,x,y)}};
                        if x<this.xmin then { x2=a.a.x; y2=a.a.y; if(this.left==null) then {nejbor=mk_Future(false)} else {nejbor=this.left.external_move(a.a,x,y)}};
                        if y<this.ymin then { x2=a.a.x; y2=a.a.y; if(this.down==null) then {nejbor=mk_Future(false)} else {nejbor=this.down.external_move(a.a,x,y)}};
                        if nejbor==null then {
                            --local collision detection
                            if this.matrix.get_val(x,y)==false then {
                                --print(this.matrix.get_val(a.a.x,a.a.y));
                                this.matrix.set(a.a.x,a.a.y,false); --remove from old pos
                                this.matrix.set(x,y,true); --add to new pos
                                a.a.move_int(x,y); --move
                                moved=true;
                                --print("moved\n");
                            }
                        } else {
                            await(nejbor);
                            if get(nejbor) then { --if left this box
                                --print(this.matrix.get_val(x2,y2));
                                this.matrix.set(x2,y2,false); --remove from old pos
                                moved=true;
                                --remove a from list
                                if parent==a then {
                                    this.agents=a.next;
                                    parent=a.next;
                                }--case for first item
                                 else {parent.next=a.next}; --other item
                            }
                        };
                            i=i+1;
                        }};
                if parent==null then {a=null;} else { --case when list is empty
                    if parent==a then { --case when a is the first item of list
                        a=a.next
                    } else {
                        parent=parent.next;
                        if parent!=null then a=parent.next else a=null}
                };
                suspend;
            };
          true;
         }

    --recives a Agent from another box
def external_move(a:Agent, x:int,y:int ) : bool {
    false;
    if(this.matrix.get_val(x,y)==true ) then { false } else {
        a.move_int(x,y);
        this.add(a);
        --print("ext_move\n");
        true;
        };

    }
}

--UTIL CLASSES FOR Box
    passive class Item {
        a : Agent
        next : Item
        def init(a:Agent) : void {this.a=a;}
    }
    {--
    passive class C_Matrix {
        origin_x : int
        origin_y : int
        locks : [bool]
        x_len : int
        def init(in_max:(int,int),in_min:(int,int)) : void {
                match (in_max,in_min) with
                    ((xmax,ymax),(xmin,ymin)) => {
                    this.origin_x=xmin;
                    this.origin_y=ymin;
                    this.x_len=xmax-xmin;
                    this.locks=new [bool]((xmax-xmin+1)*(ymax-ymin+1));
                    --print( (xmin,ymin,this.x_len,|this.locks|) );
                    for i in [0..|this.locks|] {(this.locks)[i]=false}
                };
            }
        def get_val( x:int,y:int ) : bool {
            --print((x,y,(x-this.origin_x)+((y-this.origin_y)*this.x_len)));
            (this.locks)[(x-this.origin_x)+((y-this.origin_y)*this.x_len)]
        }
        def set( x:int,y:int,value:bool ) : void {
            (this.locks)[(x-this.origin_x)+((y-this.origin_y)*this.x_len)]=value
        }
    }
    --}
def link(a:Box,b:Box) : bool {
    var aa=a.link(b);
    var bb=b.link(a);
    (get(aa)) and get(bb);
}

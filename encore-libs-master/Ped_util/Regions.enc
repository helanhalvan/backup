module Regions
import Agent_passive
import Global_funs
import SDL.SDL_Main
import Ped_util.UI

--TODO merege Reg_manager and Multi_box into a Box_manager
-- subdivides plane 4 times, genereting 4^4 regions, links them
-- replace hashmap linked list (faster iterator, never use lookup)
--TODO FIX COMPILER CRASH CAUSED BY THIS FILE
def regions(agents: [Agent],ui:bool) : void {
     let
         --sdl_main = if ui then make_UI() else null : SDL_Main
         box = new Multi_box(agents)
     in
     {
        (new Reg_manager())!loop(box,ui,sdl_main,40000)
     }
 }

class Reg_manager {
    def loop( box:Multi_box,ui:bool,sdl_main:SDL_Main,i:int) : void {
        if(ui) then {
            show(get(box.agents()),sdl_main)
        };
        get(box.move());
        if i>0 then this!loop(box,ui,sdl_main,i-1) else print("done!\n")
    }
}

--multi threaded 2D space container
class Multi_box {
    --max x and y cords
    max : (int,int)
    --min x and y cords
    min : (int,int)
    --4 sub-boxes, together covering all the space in Multi_box

    top_right : Box
    bottom_right : Box
    top_left : Box
    bottom_left : Box

    --TODO, adding a toplevel field where I can send agents that go out of bounds
    --currently I just create a massive box, and have agents in it never move
    toplevel : Box

    def init(agents:[Agent]) : void {
        let
            dx=0
            dy=0
        in {
        --find global xmax, xmin, and ymin, use to create boundries for the 2D space.
        --looks at both starting positions and waypoints
        match this.find_extreme(agents) with
            (xmax,ymax,xmin,ymin) => {this.max=(xmax,ymax);
                                      this.min=(xmin,ymin);
                                      dx=xmax-xmin;
                                      dy=ymax-ymin;
                                      --if(dx%2==0) then
                                        dx=dx/2;
                                      --else
                                        dy=dy/2;
                                      --print("{} {} {}\n",this.max,this.min,(xmax-dx,ymax-dy));
                                      this.top_right=new Box(this.max,(xmax-dx+1,ymax-dy+1 ) );
                                      this.bottom_left=new Box( (xmax-dx,ymax-dy),this.min);
                                      this.top_left= new Box( (xmax-dx,ymax),(xmin,ymax-dy+1) );
                                      this.bottom_right=new Box( (xmax,ymax-dy),(xmax-dx+1,ymin) );
                                      this.toplevel=new Box( (100000,100000), (-100000,-100000) );
                                      };
        --put each agent into exactly one box

        for a in agents {
            -- adding agents into boxes
            if( get(this.top_right.add(a))) then { () }
            else if( get(this.top_left.add(a))) then { () }
            else if( get(this.bottom_right.add(a))) then { () }
            else if( get(this.bottom_left.add(a))) then { () }
            else { print("{} didn't get in \n", a.pos);}
        };
        --LINK to toplevel
        this.top_right.default_link(this.toplevel);
        this.top_left.default_link(this.toplevel);
        this.bottom_right.default_link(this.toplevel);
        this.bottom_left.default_link(this.toplevel);

        let win=true;
        --LINKING BOXES, to allow them to pass agents between eachother
        win=win and get (this.top_right.link(this.top_left));
        win=win and get (this.top_right.link(this.bottom_right));
        win=win and get (this.top_left.link(this.top_right));
        win=win and get (this.top_left.link(this.bottom_left));
        win=win and get (this.bottom_left.link(this.bottom_right));
        win=win and get (this.bottom_left.link(this.top_left));
        win=win and get (this.bottom_right.link(this.top_right));
        win=win and get (this.bottom_right.link(this.bottom_left));

        --print("WIN={}\n",win);
        }
    }
    --get corners of box
    def max() : (int,int) {this.max}
    def min() : (int,int) {this.min}
    def center() : (int,int) {get(this.bottom_left.max()) }
    --moves all internal agents on step, returns true if any agents tried to move
    def move () : bool {
        --debug check
        let
        a = this.top_right.move()
        b = this.top_left.move()
        c = this.bottom_right.move()
        d = this.bottom_left.move()
        in {
        await(a);
        await(b);
        await(c);
        await(d);
        -- SHORT CIRCUT DOES MAKE THIS RETURN BEFORE ALL DONE!
        --(get(a)) or (get(b)) or (get(c)) or (get(d))
        }
    }
    def agents() : [(int,int)] { flatten([get(this.top_right.agents()),
                             get(this.top_left.agents()),
                             get(this.bottom_right.agents()),
                             get(this.bottom_left.agents())]) }
    def find_extreme(agents:[Agent]) : (int,int,int,int) {
        let extreme=(-10000,-10000,10000,10000);
        let i=0;
        for a in agents {
            --print("{}\n",i);
            i=i+1;
            extreme=this.extreme_check(a.pos(),extreme);
            for b in a.targets {
                extreme=this.extreme_check(b,extreme);
            }
        };
        extreme
    }
    def extreme_check(a:(int,int),b:(int,int,int,int) ) : (int,int,int,int) {
        match (a,b) with
            ((x,y),(xmax,ymax,xmin,ymin)) => (max(x,xmax),max(y,ymax),min(x,xmin),min(y,ymin))
    }
}

--single threaded 2D space container
--contains all Agents in a given 2D region of space
--assumess cordnate system where Y is height and X is with, so increasing X means further to the right
class Box {
-- min and max are inclusive
-- max is the greatest X value and the greatest Y value box contains
-- min is the smalles X and Y values
 xmax : int
 ymax : int
 xmin : int
 ymin : int
 up : Box
 down : Box
 left : Box
 right : Box
 matrix : C_Matrix
 agents : Item

def init(in_max:(int,int), in_min:(int,int) ) : void {
    this.matrix= new C_Matrix(in_max,in_min);
    match in_max with (x,y) => {this.xmax=x;this.ymax=y};
    match in_min with (x,y) => {this.xmin=x;this.ymin=y};
    }
--getters for borders
def min() : (int,int) { (this.xmin,this.ymin) }
def max() : (int,int) { (this.xmax,this.ymax) }
-- SLOW BUT ONLY USED BY UI
def agents() : [(int,int)] {
    let
        cur= this.agents
        i=0
    in {
    while cur!=null { i=i+1; cur=cur.next };
    let ret= new [(int,int)](i);
    i=0;
    while cur!=null {
        ret[i]=cur.a.pos();
        i=i+1;
        cur=cur.next
        };
    ret
    }}
 -- TODO add bounds check here, ret false if not working
def add(a:Agent) : bool {
    this.matrix.set(a.x,a.y,true); --add to collison matrix
    let cur = this.agents;
    while cur.next!=null { cur=cur.next };
    cur.next = new Item(a); --append linked list
    true
}
--if the arguements shares a border with this box, it's added to the apropriate edge and returns true
--otherwise returns false
def link(a:Box) : bool {
    let c=a.max();
    let d=a.min();
    await(c);
    await(d);
    match (this.xmax,this.ymax,this.xmin,this.ymin,get(c),get(d)) with
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_1+1) == x_min_2) => {this.right=a;print("right\n");true }
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_1+1) == y_min_2) => {this.up=a;   print("up\n"); true }
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_2+1) == x_min_1) => {this.left=a; print("left\n");true }
        ( x_max_1,y_max_1,x_min_1,y_min_1,(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_2+1) == y_min_1) => {this.down=a; print("down\n");true }
        _ => { false }
    }
def default_link(a:Box) : void {
        this.up=a;
        this.down=a;
        this.left=a;
        this.right=a;
    }
 --moves all agents in the box once
 --returns true
def move(): bool {
        let cur = this.agents;
        if cur!=null then {
       while cur.next!=null { --starts from second item in linked list for easy delete
            let
                a = cur.next
                desired = a.a.next()
                i = 0
                nejbor = null:Fut bool
                stillhere = true
            in {
            while( i < |desired| and stillhere == true) {
                match (desired[i],this.xmax,this.ymax,this.xmin,this.ymin) with
                    --external move
                    ((x,y),x_max,y_max,x_min,y_min) when (x>x_max) => { nejbor=this.right.external_move(a.a.copy(),x,y ); () }
                    ((x,y),x_max,y_max,x_min,y_min) when (x<x_min) => { nejbor=this.left.external_move(a.a.copy(),x,y ); () }
                    ((x,y),x_max,y_max,x_min,y_min) when (y>y_max) => { nejbor=this.up.external_move(a.a.copy(),x,y ); ()  }
                    ((x,y),x_max,y_max,x_min,y_min) when (y<y_min) => { nejbor=this.down.external_move(a.a.copy(),x,y ); () }
                    _ => { () };
                if nejbor==null then {
                    --local collision detection
                    if matrix.get_val()==false then {
                        matrix.set(a.x,a.y,false); --remove from old pos
                        match desired[i] with (x,y) => matrix.set(x,y,true); --add to new pos
                        a.move(desired[i]); --move
                    }
                } else {
                        await(nejbor);
                    if get(nejbor) then { --if left this box
                        matrix.set(a.x,a.y,false); --remove from old pos
                        cur.next=a.next --remove from list
                    }
                };
                    i=i+1;
                };
            }};
         let --first item have it's own case
             a = cur
             desired = a.a.next()
             i = 0
             nejbor = null:Fut bool
             stillhere = true
         in {
         while( i < |desired| and stillhere == true) {

             match (desired[i],this.max,this.min) with
                 --external move
                 ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max) => { nejbor=this.right.external_move(a.a.copy(),x,y ); () }
                 ((x,y),(x_max,y_max),(x_min,y_min)) when (x<x_min) => { nejbor=this.left.external_move(a.a.copy(),x,y ); () }
                 ((x,y),(x_max,y_max),(x_min,y_min)) when (y>y_max) => { nejbor=this.up.external_move(a.a.copy(),x,y ); ()  }
                 ((x,y),(x_max,y_max),(x_min,y_min)) when (y<y_min) => { nejbor=this.down.external_move(a.a.copy(),x,y ); () }
                 _ => { () };
             if nejbor==null then {
                 --local collision detection
                 if matrix.get_val()==false then {
                     matrix.set(a.x,a.y,false); --remove from old pos
                     match desired[i] with (x,y) => matrix.set(x,y,true); --add to new pos
                     a.move(desired[i]); --move
                 }
             } else {
                     await(nejbor);
                 if get(nejbor) then {
                     matrix.set(a.x,a.y,false); --remove from old pos
                     this.agents=null --remove from list
                 }
             };
                 i=i+1;
             };
         }
        };
          true
         }

    --recives a Agent from another box
def external_move(a:Agent, x:int,y:int ) : bool {
    if(this.matrix.get_val(x,y) ) then { false } else {
        a.move(pos);
        this.add(a);
        true
        }
    }
}


--UTIL CLASSES FOR Box
    passive class Item {
        a : Agent
        next : Item
        def init(a:Agent) : void {this.a=a;}
    }
    passive class C_Matrix {
        origin_x : int
        origin_y : int
        locks : [bool]
        x_len : int
        def init(in_max:(int,int),in_min:(int,int)) : void {
                match (in_max,in_min) with
                    ((xmax,ymax),(xmin,ymin)) => {
                    this.origin_x=xmin;
                    this.origin_y=ymin;
                    this.x_len=xmax-xmin;
                    this.locks=new [bool]((xmax-xmin+1)*(ymax-ymin+1));
                    --print( (xmin,ymin,this.x_len,|this.locks|) );
                    for i in [0..|this.locks|] {(this.locks)[i]=false}
                };
            }
        def get_val( x:int,y:int ) : bool {
            --print((x,y,(x-this.origin_x)+((y-this.origin_y)*this.x_len)));
            (this.locks)[(x-this.origin_x)+((y-this.origin_y)*this.x_len)]
        }
        def set( x:int,y:int,value:bool ) : void {
            (this.locks)[(x-this.origin_x)+((y-this.origin_y)*this.x_len)]=value
        }
    }
--}

module Box
import Agent_passive
import Collections.HashMap
import Global_funs
def box(agents: [Agent], ui:bool) : void {
     let
        sdl_main = if ui then make_UI() else null : SDL_Main
        superbox = new_Box(agents)
     in
    this!box_loop(40000, superbox, ui,sdl_main)
}
def box_loop(i:int, superbox:Box, ui:bool,sdl_main:SDL_Main) : void {
    get(superbox.move());
    --print(i);
    if ui then {
        show(get(superbox.agents()),sdl_main);
    };
    if i>0 then this!box_loop(i-1,superbox,ui,sdl_main) else {
        superbox.destroy() -- TODO implement
    };
}
def new_Box(agents:[Agent]) : Box {
    let
        box=new Box(find_extreme(agents),Nothing : Maybe Box, 3)
    in {
    for a in agents {
        get(box.add(a))
    };
    box
}}

{-            let iterator = new HashMapIterator<Agent>(this.agents.get_data());
            let ret = new [(int,int)](this.agents.size());
            let i=0;
            while iterator.has_next() {
                let a = {match iterator.next() with Just entry => {entry.value}};
                print("{}\n",a.pos);
                ret[i]=a.pos;
                i=i+1;
            };
            print("{} {}\n",|ret|,i);
            ret-}

class Box {
    toplevel : Maybe Box
    space : (int,int,int,int) --maxx maxy minx miny
    multi : [Box]
    agents : Agent_struct
    def destroy() : void {
        --TODO
        ()
    }
    def agents() : [(int,int)] {
        if |this.multi|==0 then {
            let
                b = new [(int,int)](this.agents.size())
                hashmap = this.agents.get_data()
                a = new HashMapIterator<Agent>(hashmap)
                i = 0
            in {
                while a.has_next() {
                    b[i]=match a.next() with Just entry => entry.value.pos();
                    i=i+1
                };
                if i < this.agents.size() then
                    {
                        let c = new [(int,int)](i);
                            for index in [0..i] {
                                c[index]=b[index];
                            };
                            c
                    } else b
                }
        } else {
            let a = [
                get(((this.multi)[0]).agents()),
                get(((this.multi)[1]).agents()),
                get(((this.multi)[2]).agents()),
                get(((this.multi)[3]).agents())
            ];
            print("{}\n",(a[0])[0]);
            flatten( a )
        }
    }
    def init(space:(int,int,int,int), toplevel: Maybe Box,levels_left:int) : void {
        this.space=space;
        this.toplevel=toplevel;
            match space with
                (xmax,ymax,xmin,ymin) => {
            let
                dx=xmax-xmin
                dy=ymax-ymin
                myface=Just this
                in {
                  dx=dx/2;
                  dy=dy/2;

                if(levels_left>0) then {
                  this.multi = new [Box](4);
                  this.multi[0]= new Box( (xmax,ymax,xmax-dx+1,ymax-dy+1), myface,levels_left-1);
                  this.multi[1]= new Box( (xmax-dx,ymax-dy,xmin,ymin),      myface,levels_left-1);
                  this.multi[2]= new Box( (xmax-dx,ymax,xmin,ymax-dy+1), myface,levels_left-1);
                  this.multi[3]= new Box( (xmax,ymax-dy,xmax-dx+1,ymin), myface,levels_left-1);
                    ()
                    } else {
                    --print("bottom\n");
                  this.multi = new [Box](0);
                  this.agents= new Agent_struct();
                    ()
                    }
        }}; ()
    }
    def space() : (int,int,int,int) {this.space}
    def add(a:Agent) : void {
        --if not inside(a.pos(),this.space) then false else {
                if |this.multi| == 0 then {
                    this.agents.add(a);
                } else {
                for item in this.multi {
                    if ( inside(a.pos(), this.space) ) then {

                        item!add(a)}
                };};
            --};
            true
    }
    def move() : int {
        if |this.multi| == 0 then {
           let iterator = new HashMapIterator<Agent>(this.agents.get_data());
           while iterator.has_next() {
                let
                    a = {match iterator.next() with Just entry => {entry.value}}
                    desired = a.next()
                    i = 0
                    nejbor = false
                    stillhere = true
                in {
                if |desired| == 0 then stillhere=false; --happens if TTL runs out
                while( i < |desired| and stillhere == true) {
                    if( inside(desired[i],this.space) ) then {
                        if(this.agents.isin(desired[i])) then {
                            i=i+1;
                            embed void { continue; } end;
                            ()}
                        else {
                            a.move(desired[i]);
                            embed void { break; } end}
                    } else {
                        nejbor=this.external_move(a.copy(),desired[i] ); () };
                        if nejbor then {
                            stillhere=false;
                            embed void { break; } end
                            }
                        else {
                            stillhere=true;
                            i=i+1
                        }
                };
                if (stillhere == false) then {
                        this.agents.remove(a);
                    }
                }};
            this.agents.size()
        } else {
            --PARRALLEL MOVE
            let f = new [Fut int](4);
                f[0] = ((this.multi)[0]).move();
                f[1] = ((this.multi)[1]).move();
                f[2] = ((this.multi)[2]).move();
                f[3] = ((this.multi)[3]).move();
            let ret = 0;
                for a in f {await(a)};
                for a in f {ret=ret+get(a)};
                ret
        }
    }
    def external_move(a:Agent, pos:(int,int)) : bool {
        if( not inside(pos,this.space) ) then {
            match this.toplevel with
                    Just tl => {
                                let a = tl.external_move(a,pos);
                                await(a);
                                get(a);}
                    _ => {print("AGENT IS TRYING TO ESCAPE SIMULATION\n"); false}
        } else {
        if |this.multi|==0 then {
            if(this.agents.size()==0) then {
                a.move(pos);
                this.agents.add(a);
                true
            } else {
                if(this.agents.isin(pos)) then { false } else {
                a.move(pos);
                this.agents.add(a);
                true
            }}
            } else {
            let ret = mk_Future(false);
            for item in this.multi {
                if inside(pos, get(item.space()) ) then {
                    ret=item.external_move(a,pos);
                    }
                };
            await(ret);
            get(ret);
        }}
    }
}

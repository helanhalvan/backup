module Box
import Agent_passive
import Collections.HashMap
import Global_funs
def new_Box(agents:[Agent]) : Box {
    new Box(find_extreme(agents),Nothing : Maybe Box, 3);
}
def find_extreme(agents:[Agent]) : (int,int,int,int) {
    let extreme=(-10000,-10000,10000,10000);
    let i=0;
    for a in agents {
        --print("{}\n",i);
        i=i+1;
        extreme=extreme_check(a.pos(),extreme);
        for b in a.targets {
            extreme=extreme_check(b,extreme);
        }
    };
    extreme
}
def extreme_check(a:(int,int),b:(int,int,int,int) ) : (int,int,int,int) {
    match (a,b) with
        ((x,y),(xmax,ymax,xmin,ymin)) => (max(x,xmax),max(y,ymax),min(x,xmin),min(y,ymin))
}
class Box {
    toplevel : Maybe Box
    space : (int,int,int,int) --minx miny maxx maxy
    multi : [Box]
    agents : Agent_struct
    def init(space:(int,int,int,int), toplevel: Maybe Box,levels_left:int) : void {
        this.space=space;
        this.toplevel=toplevel;
            match space with
                (xmin,ymin,xmax,ymax) => {
            let
                dx=xmax-xmin
                dy=ymax-ymin
                myface=Just this
                in {
                  dx=dx/2;
                  dy=dy/2;

                if(levels_left>0) then {
                  this.multi = new [Box](4);
                  this.multi[0]= new Box( (xmax,ymax,xmax-dx+1,ymax-dy+1), myface,levels_left-1);
                  this.multi[1]= new Box( (xmax-dx,ymax-dy,xmin,ymin),      myface,levels_left-1);
                  this.multi[2]= new Box( (xmax-dx,ymax,xmin,ymax-dy+1), myface,levels_left-1);
                  this.multi[3]= new Box( (xmax,ymax-dy,xmax-dx+1,ymin), myface,levels_left-1);
                    ()
                    } else {
                  this.multi = new [Box](0);
                    ()
                    }
        }}; ()
    }
    def space() : (int,int,int,int) {this.space}
    def add(a:Agent) : void {
        if not inside(a.pos(),this.space) then false else {
                for item in this.multi {
                    if ( inside(a.pos(), this.space) ) then item.add(a)
                };
                if |this.multi| == 0 then {
                    this.agents.add(a);
                }
            };
            true
    }
    def move() : int {
        if |this.multi| == 0 then {
           let iterator = new HashMapIterator<Agent>(this.agents.get_data());
           while iterator.has_next() {
                let
                    a = {match iterator.next() with Just entry => {entry.value}}
                    desired = a.next()
                    i = 0
                    nejbor = false
                    stillhere = true
                in {
                if |desired| == 0 then stillhere=false; --happens if TTL runs out
                while( i < |desired| and stillhere == true) {
                    if( inside(desired[i],this.space) ) then {
                        if(this.agents.isin(desired[i])) then {
                            i=i+1;
                            embed void { continue; } end;
                            ()}
                        else {
                            a.move(desired[i]);
                            embed void { break; } end}
                    } else {
                        nejbor=this.external_move(a.copy(),desired[i] ); () };
                        if nejbor then {
                            stillhere=false;
                            embed void { break; } end
                            }
                        else {
                            stillhere=true;
                            i=i+1
                        }
                };
                if (stillhere == false) then {
                        this.agents.remove(a);
                    }
                }};
            this.agents.size()
        } else {
            --PARRALLEL MOVE
            let f = new [Fut int](4);
                f[0] = ((this.multi)[0]).move();
                f[1] = ((this.multi)[1]).move();
                f[2] = ((this.multi)[2]).move();
                f[3] = ((this.multi)[3]).move();
            let ret = 0;
                for a in f {await(a)};
                for a in f {ret=ret+get(a)};
                ret
        }
    }
    def external_move(a:Agent, pos:(int,int)) : bool {
        if( not inside(pos,this.space) ) then {
            match this.toplevel with
                    Just tl => {
                                let a = tl.external_move(a,pos);
                                await(a);
                                get(a);}
                    _ => {print("AGENT IS TRYING TO ESCAPE SIMULATION\n"); false}
        } else {
        if |this.multi|==0 then {
            if(this.agents.size()==0) then {
                a.move(pos);
                this.agents.add(a);
                true
            } else {
                if(this.agents.isin(pos)) then { false } else {
                a.move(pos);
                this.agents.add(a);
                true
            }}
            } else {
            let ret = mk_Future(false);
            for item in this.multi {
                if inside(pos, get(item.space()) ) then {
                    ret=item.external_move(a,pos);
                    }
                };
            await(ret);
            get(ret);
        }}
    }
}

module Agent_passive
--import Collections.HashMap
--import Collections.HashCode
import Ped_util.Global_funs
--import Collections.Map

passive class Agent {
    hash_code : uint                --global unique id IMMUTABLE
    --pos : (int,int)         --current position MUTABLE
    x : int
    y : int
    --targets : [(int,int)]   --waypoints, a list of positions to go to IMMUTABLE
    targets_x : [int]
    targets_y : [int]
    targets_size : [int]    -- target radius
    i : int                 --index of targets MUTABLE
    ttl : int     --number of steps before calling it a day
    def init(in_pos:(int,int), list:[(int,int)], targets_size:[int], in_id:int,ttl:int) : void {
        --print("POS ok\n");
        match in_pos with (x,y) => {this.x=x;this.y=y;};
        this.i=0;
        this.targets_x= new [int](|targets_size|);
        this.targets_y= new [int](|targets_size|);
        --this.targets=list;
        this.targets_size=targets_size;
        for index in [0..|list|-1] {
            --print("{} starting\n", index);
            match list[index] with (x,y)=> {
                --print("{} ok\n", index);
                (this.targets_x)[index]=x;
                (this.targets_y)[index]=y;
            }
        };
        this.hash_code=in_id;
        this.ttl=ttl;
        ()
    }
    -- --returns places the agent can and want to go to
    -- --can => an agent can only go up, down, left or right
    -- --want => an agent only want to go closer to their next waypoint

    --double length = diffX * diffX + diffY * diffY;
    --double r = destination->getr();
    --agentReachedDestination = length < (r * r);

    def next() : [(int,int)] {
            let
                x1=this.x
                y1=this.y
            in {
                var x2=this.targets_x[this.i];
                var y2=this.targets_y[this.i];
                var xdiff=x1-x2;
                var ydiff=y1-y2;
                var lenSquare=(xdiff*xdiff)+(ydiff*ydiff);
                var invlen = invSqrt(lenSquare);
                var ret = new [(int,int)](3);
            if lenSquare< (this.targets_size[this.i]*this.targets_size[this.i]) then
                {this.i=this.i+1;};
            if |this.targets_size| == this.i then
                {this.i=0;};
                x2=this.targets_x[this.i];
                y2=this.targets_y[this.i];
                xdiff=x1-x2;
                ydiff=y1-y2;
                lenSquare=(xdiff*xdiff)+(ydiff*ydiff);
                invlen = invSqrt(lenSquare);
            let
                desired_x=x1+round( (x2+xdiff)*invlen )
                desired_y=y1+round( (y2+ydiff)*invlen )
            in {
                xdiff=desired_x-x1;
                ydiff=desired_y-y1;
                ret[0]=(desired_x,desired_y);
                ret[1]=(desired_x,desired_y);
                ret[2]=(desired_x,desired_y);

                if(xdiff==0 or ydiff==0) then {
                    --if(xdiff==0 and ydiff==0) then print("xdiff and ydiff == 0, invariant VIOLATED {} {}\n",xdiff,ydiff);
                    ret[1]=(desired_x+ydiff,desired_y+xdiff);
                    ret[2]=(desired_x-ydiff,desired_y-xdiff);
                } else {
                    ret[1]=(desired_x,y1);
                    ret[2]=(x1,desired_y);
                };
                --}
                for i in [0..2] {
                    if man_distance(ret[i],(this.x,this.y))<1 or man_distance(ret[i],(this.x,this.y))>2 then {
                        unless equal(ret[i],(this.x,this.y)) then {
                        print("\nMOVING {} STEPS {} {} {}\n {} {}\n",man_distance(ret[i],(this.x,this.y)),
                        (this.x,this.y),ret[i], i,
                        (xdiff,ydiff),invlen);
                        };
                        --while true { () };
                    } --else {print(xdiff,ydiff);}
                }};
                ret
}}
{-
    def next() : [(int,int)] {
            --this.ttl=this.ttl-1; --update step counter
            var ret = new [(int,int)](3);
            val len=distance_int( this.x,this.y, (this.targets_x)[this.i], (this.targets_y)[this.i] );
            if len<this.targets_size[this.i] then
                {this.i=this.i+1;};
            if |this.targets_size| == this.i then
                {this.i=0;};

            var x=0.5;
            x=this.x;
            var y=0.5;
            y=this.y;
            var diffx=0.5;
            diffx=this.targets_x[this.i]-x;
            var diffy=0.5;
            diffy=(this.targets_y[this.i]-y);
            val desiredx=round( x+ (diffx/len) );
            val desiredy=round( y+ (diffy/len) );
            val diffx2=this.x-desiredx;
            val diffy2=this.y-desiredy;
            {
                ret[0]=(desiredx,desiredy);
                if(diffx2==0 or diffy2==0) then {
                ret[1]=(desiredx+diffy2,desiredy+diffx2);
                ret[2]=(desiredx-diffy2,desiredy-diffx2);
                } else {
                ret[1]=(desiredx,this.y);
                ret[2]=(this.x,desiredy);
                };
                for i in [0..2] {
                    if man_distance(ret[i],(this.x,this.y))>2 then {
                        print("MOVING FURTHER THEN ONE STEP AT THE TIME, {} {} {}\n",man_distance(ret[i],(this.x,this.y)),(this.x,this.y),ret[i]);
                    }
                };
                ret
            }}
-}
    --updates the current position
    --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void {
        match in_pos with (x,y) => {this.x=x;this.y=y;}
    }
    def move_int(x:int,y:int) : void {
        this.x=x;
        this.y=y;
    }
                                --getter for position, used for collision detection
    def pos() : (int,int)
        (this.x,this.y)

    --unused, broken
                                    --copy constructor, hopefully I won't need that one in the finnal version
    {-
    def copy() : Agent {
            let q = (this.x,this.y);
            let qq = new [(int,int)](|this.targets|);
                for i in [0..(|qq|-1)] {
                    --this change exposes that the tupple this.targets[i] get mangled somewhere
                    qq[i]=this.targets[i];
                    --qq[i]={match this.targets[i] with (x,y) => (x,y)};
                };
            let w = new Agent(q, qq, copy_ar(this.targets_size),this.hash_code,this.ttl);
                w.i=this.i;
                w
            }
    -}
        }

--data structure for holding multiple agents

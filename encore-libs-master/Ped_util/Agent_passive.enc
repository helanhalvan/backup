module Agent_passive
--import Collections.HashMap
--import Collections.HashCode
import Ped_util.Global_funs
--import Collections.Map

passive class Agent {
    hash_code : uint                --global unique id IMMUTABLE
    --pos : (int,int)         --current position MUTABLE
    x : int
    y : int
    --targets : [(int,int)]   --waypoints, a list of positions to go to IMMUTABLE
    targets_x : [int]
    targets_y : [int]
    targets_size : [int]    -- target radius
    i : int                 --index of targets MUTABLE
    ttl : int   --unused            --number of steps before calling it a day
    def init(in_pos:(int,int), list:[(int,int)], targets_size:[int], in_id:int,ttl:int) : void {
        --print("POS ok\n");
        match in_pos with (x,y) => {this.x=x;this.y=y;};
        this.i=0;
        this.targets_x= new [int](|targets_size|);
        this.targets_y= new [int](|targets_size|);
        --this.targets=list;
        this.targets_size=targets_size;
        for index in [0..|list|-1] {
            --print("{} starting\n", index);
            match list[index] with (x,y)=> {
                --print("{} ok\n", index);
                (this.targets_x)[index]=x;
                (this.targets_y)[index]=y;
            }
        };
        this.hash_code=in_id;
        this.ttl=ttl;
        ()
    }
    -- --returns places the agent can and want to go to
    -- --can => an agent can only go up, down, left or right
    -- --want => an agent only want to go closer to their next waypoint
    -- lowers TTL

{-
  int diffX = pDesired.first - agent->getX();
  int diffY = pDesired.second - agent->getY();
  if (diffX == 0 || diffY == 0)
  {
    // Agent wants to walk straight to North, South, West or East
    p1 = std::make_pair(pDesired.first + diffY, pDesired.second + diffX); //WALK straight there
    p2 = std::make_pair(pDesired.first - diffY, pDesired.second - diffX); //walk in opposite direction
    //p2 = std::make_pair(agent->getX(),agent->getY());
  }
  else {
    // Agent wants to walk diagonally
    p1 = std::make_pair(pDesired.first, agent->getY());
    p2 = std::make_pair(agent->getX(), pDesired.second);
  }
-}

    def next() : [(int,int)] {
            if distance_int( this.x,this.y, (this.targets_x)[this.i], (this.targets_y)[this.i] )<this.targets_size[this.i] then
                {this.i=this.i+1;};
            if |this.targets_size| == this.i then
                {this.i=0;};
            let
                x1=this.x
                y1=this.y
                x2=this.targets_x[this.i]
                y2=this.targets_y[this.i]
                dx=x1-x2
                dy=y1-y2
            in {
                if x1>x2 and y1>y2 then { [(x1-1,y1),(x1,y1-1)] } else {
                if x1<x2 and y1<y2 then { [(x1+1,y1),(x1,y1+1)] } else {
                if x1<x2 and y1>y2 then { [(x1+1,y1),(x1,y1-1)] } else {

                if x1>x2           then { [(x1-1,y1) ] } else {
                if y1>y2           then { [(x1,y1-1) ] } else {
                if x1<x2           then { [(x1+1,y1) ] } else {
                if y1<y2           then { [(x1,y1+1) ] } else { new [(int,int)](0) }}}}}}}
 --}
{-
                if x1>x2           then { [(x1-1,y1),(x1+1,y1) ] } else {
                if y1>y2           then { [(x1,y1-1),(x1,y1+1) ] } else {
                if x1<x2           then { [(x1+1,y1),(x1-1,y1) ] } else {
                if y1<y2           then { [(x1,y1+1),(x1,y1-1) ] } else { new [(int,int)](0) }}}}}}}
--}
            }}
            {-
            match (this.pos, this.targets[this.i]) with
                ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { [(x1-1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { [(x1+1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { [(x1-1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { [(x1+1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1>x2           => { [(x1-1,y1)] }
                ((x1,y1), (x2,y2)) when y1>y2           => { [(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1<x2           => { [(x1+1,y1)] }
                ((x1,y1), (x2,y2)) when y1<y2           => { [(x1,y1+1)] }
                _ => { print("THIS SHOULD NEVER HAPPEN, |targets| = {} ", |this.targets|); new [(int,int)](0) }
            -}
                            --updates the current position
                            --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void {
        match in_pos with (x,y) => {this.x=x;this.y=y;}
    }
    def move_int(x:int,y:int) : void {
        this.x=x;
        this.y=y;
    }
                                --getter for position, used for collision detection
    def pos() : (int,int)
        (this.x,this.y)

    --unused, broken
                                    --copy constructor, hopefully I won't need that one in the finnal version
    {-
    def copy() : Agent {
            let q = (this.x,this.y);
            let qq = new [(int,int)](|this.targets|);
                for i in [0..(|qq|-1)] {
                    --this change exposes that the tupple this.targets[i] get mangled somewhere
                    qq[i]=this.targets[i];
                    --qq[i]={match this.targets[i] with (x,y) => (x,y)};
                };
            let w = new Agent(q, qq, copy_ar(this.targets_size),this.hash_code,this.ttl);
                w.i=this.i;
                w
            }
    -}
        }

--data structure for holding multiple agents

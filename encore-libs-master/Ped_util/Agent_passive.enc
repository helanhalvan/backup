module Agent_passive
--import Collections.HashMap
--import Collections.HashCode
import Ped_util.Global_funs
--import Collections.Map

passive class Agent {
    hash_code : uint                --global unique id IMMUTABLE
    --pos : (int,int)         --current position MUTABLE
    x : int
    y : int
    --targets : [(int,int)]   --waypoints, a list of positions to go to IMMUTABLE
    targets_x : [int]
    targets_y : [int]
    targets_size : [int]    -- target radius
    i : int                 --index of targets MUTABLE
    ttl : int     --number of steps before calling it a day
    def init(in_pos:(int,int), list:[(int,int)], targets_size:[int], in_id:int,ttl:int) : void {
        --print("POS ok\n");
        match in_pos with (x,y) => {this.x=x;this.y=y;};
        this.i=0;
        this.targets_x= new [int](|targets_size|);
        this.targets_y= new [int](|targets_size|);
        --this.targets=list;
        this.targets_size=targets_size;
        for index in [0..|list|-1] {
            --print("{} starting\n", index);
            match list[index] with (x,y)=> {
                --print("{} ok\n", index);
                (this.targets_x)[index]=x;
                (this.targets_y)[index]=y;
            }
        };
        this.hash_code=in_id;
        this.ttl=ttl;
        ()
    }
    -- --returns places the agent can and want to go to
    -- --can => an agent can only go up, down, left or right
    -- --want => an agent only want to go closer to their next waypoint
    def next() : [(int,int)] {
            --this.ttl=this.ttl-1; --update step counter
            var ret = new [(int,int)](3);
            val len=distance_int( this.x,this.y, (this.targets_x)[this.i], (this.targets_y)[this.i] );
            if len<this.targets_size[this.i] then
                {this.i=this.i+1;};
            if |this.targets_size| == this.i then
                {this.i=0;};
            let
                x1=this.x
                y1=this.y
                x2=this.targets_x[this.i]
                y2=this.targets_y[this.i]
                dx=round( ((x1-x2)*1.0) /len)
                dy=round( ((y1-y2)*1.0) /len)
                next_x=x1-dx
                next_y=y1-dy
            in {
                ret[0]=(next_x,next_y);
                if(dx==0 or dy==0) then {
                    ret[1]=(next_x+dy,next_y+dx);
                    ret[2]=(next_x-dy,next_y-dx);
                } else {
                    ret[1]=(next_x,y1);
                    ret[2]=(x1,next_y);
                };
                for i in [0..2] {
                    if man_distance(ret[i],(this.x,this.y))>2 then {
                        print("MOVING FURTHER THEN ONE STEP AT THE TIME {} {} {} {}\n {} {} {} {} {}\n",man_distance(ret[i],(this.x,this.y)),(this.x,this.y),ret[i], i, (x1,y1), (x2,y2),(dx,dy),(x1-x2,y1-y2),len);
                        while true { () };
                    }
                };
                ret
}}
{-
    def next() : [(int,int)] {
            --this.ttl=this.ttl-1; --update step counter
            var ret = new [(int,int)](3);
            val len=distance_int( this.x,this.y, (this.targets_x)[this.i], (this.targets_y)[this.i] );
            if len<this.targets_size[this.i] then
                {this.i=this.i+1;};
            if |this.targets_size| == this.i then
                {this.i=0;};

            var x=0.5;
            x=this.x;
            var y=0.5;
            y=this.y;
            var diffx=0.5;
            diffx=this.targets_x[this.i]-x;
            var diffy=0.5;
            diffy=(this.targets_y[this.i]-y);
            val desiredx=round( x+ (diffx/len) );
            val desiredy=round( y+ (diffy/len) );
            val diffx2=this.x-desiredx;
            val diffy2=this.y-desiredy;
            {
                ret[0]=(desiredx,desiredy);
                if(diffx2==0 or diffy2==0) then {
                ret[1]=(desiredx+diffy2,desiredy+diffx2);
                ret[2]=(desiredx-diffy2,desiredy-diffx2);
                } else {
                ret[1]=(desiredx,this.y);
                ret[2]=(this.x,desiredy);
                };
                for i in [0..2] {
                    if man_distance(ret[i],(this.x,this.y))>2 then {
                        print("MOVING FURTHER THEN ONE STEP AT THE TIME, {} {} {}\n",man_distance(ret[i],(this.x,this.y)),(this.x,this.y),ret[i]);
                    }
                };
                ret
            }}
-}
    --updates the current position
    --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void {
        match in_pos with (x,y) => {this.x=x;this.y=y;}
    }
    def move_int(x:int,y:int) : void {
        this.x=x;
        this.y=y;
    }
                                --getter for position, used for collision detection
    def pos() : (int,int)
        (this.x,this.y)

    --unused, broken
                                    --copy constructor, hopefully I won't need that one in the finnal version
    {-
    def copy() : Agent {
            let q = (this.x,this.y);
            let qq = new [(int,int)](|this.targets|);
                for i in [0..(|qq|-1)] {
                    --this change exposes that the tupple this.targets[i] get mangled somewhere
                    qq[i]=this.targets[i];
                    --qq[i]={match this.targets[i] with (x,y) => (x,y)};
                };
            let w = new Agent(q, qq, copy_ar(this.targets_size),this.hash_code,this.ttl);
                w.i=this.i;
                w
            }
    -}
        }

--data structure for holding multiple agents

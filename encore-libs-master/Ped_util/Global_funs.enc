module Global_funs
import Agent_passive
import XML.XML

--xmax ymax xmin ymin
def find_extreme(agents:[Agent]) : (int,int,int,int) {
    var extreme=(-10000,-10000,10000,10000);
    var i=0;
    for a in agents {
        --print("{}\n",i);
        i=i+1;
        extreme=extreme_check(a.pos(),extreme);
        for index in [0..|a.targets_x|-1] {
            --print( (a.targets_x[index],a.targets_y[index],index) );
            extreme=extreme_check( (a.targets_x[index],a.targets_y[index]),extreme);
        }
    };
    match extreme with (xmax,ymax,xmin,ymin) => (xmax+10,ymax+10,xmin-10,ymin-10)
}
def extreme_check(a:(int,int),b:(int,int,int,int) ) : (int,int,int,int) {
    match (a,b) with
        ((x,y),(xmax,ymax,xmin,ymin)) => {(max(x,xmax),max(y,ymax),min(x,xmin),min(y,ymin))}
}

def clock() : int {
    var x=0;
    embed void { #{x}=clock(); } end;
    x
}
def printtime(x:int) : void {
   embed void { printf("%i seconds\n%i cycles\n", #{x}/CLOCKS_PER_SEC, #{x}); } end;
}
def mk_Future(n : bool) : Fut bool
 embed Fut bool
   future_t *fut = future_mk(_ctx, ENCORE_PRIMITIVE);
   future_fulfil(_ctx, fut, (encore_arg_t) {.i = #{n}});
   fut;
 end
def inside(pos:(int,int),space:(int,int,int,int) ) : bool {
    match (pos,space) with
        ((x,y),(xmax,ymax,xmin,ymin)) when x>xmax or x<xmin or y>ymax or y<ymin => false
        _ => true
}
def copy_ar(arr:[int]) : [int] {
    var a2=new[int](|arr|);
    var i=0;
    for a in arr {
        --print("{} \n", a);
        a2[i]=a;
        i=i+1
    };
    a2
}
def copy_tr(arr:[(int,int)]) : [(int,int)] {
        var a2=new [(int,int)](|arr|);
        var i=0;
        for a in arr {
            a2[i]=a;
            i=i+1;
        };
        a2
}
def flatten(listlist:[[(int,int)]]): [(int,int)] {
        var len=0;
        for a in listlist {
            len=len+ |a| ;
        };
        var list=new[(int,int)](len);
        var i=0;
        for a in listlist {
            for b in a {
                list[i]=b;
                i=i+1;
                --print("merging {}\n",b);
            }
        };
        unless (i==len) then print("BAD MERGE\n");
        list
    }
def max(a:int,b:int) : int {
    if(a>b) then a
    else b
    }
def min(a:int,b:int) : int {
    if(a<b) then a
    else b
    }
def int_or_0 (i:Maybe int ) : int {
        match i with
            Just nr => nr
            _ => {print("or0\n"); 0}
   }
def string_or_empty( i: Maybe String ) : String {
        match i with
            Just nr => {nr}
            _ => {print("orEmpty\n");""}
    }
def rand() : int {
    var x=0;
    embed void { #{x}=rand(); } end;
    x
}
def sleep(x:real) : void {
    embed void { sleep( #{x} ); } end
}
def rot(nr:int) : int {
    embed void { #{nr}=sqrt(#{nr}); } end;
    nr
}
def abs(a:int) : int {
    if a>0 then a else a*(-1)
}
def man_distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => abs(x1-x2)+abs(y1-y2)
         _ => { print("THIS WILL NEVER HAPPEN!"); 1/0 }
}
def man_distance_int(x1:int,y1:int,x2:int,y2:int) : int {
        abs(x1-x2)+abs(y1-y2)
}
def round(x:real) : int {
    val i=0;
    embed void { #{i}=round(#{x}); } end;
    i
}
def distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => rot(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
         _ => { print("THIS WILL NEVER HAPPEN!"); 1/0 }
}
def distance_int(x1:int,y1:int,x2:int,y2:int) : real {
    rot(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
}
def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with
    ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
    _ => false
}
def parse_file(fname:String) : [Agent] {
       var
           sen = new XML_lib();
           var file= new XML_node();
        {
           match sen.file_to_xml(fname) with
           Just xml => {file=xml; --print("\n\nWORKED!\n")
                }
           Nothing => print("\n\nBADXML!\n");
        var
            xml_way = file.children_named("waypoint");
            var waypoints=new [(int,int)] ( |xml_way| );
            var waypoints_distance=new [int] ( |xml_way| );
            var i=0;
        {
            --print(|xml_way|);
            for a in xml_way {
                waypoints[i]={
                match (a.attribute_value("x").to_int(),a.attribute_value("y").to_int()) with
                    (Just x,Just y) => (x,y)
                    _ => { print("BADINT!\n"); (0,0)}};
                waypoints_distance[i]= int_or_0(a.attribute_value("r").to_int());
                --print("derp {}\n",waypoints_distance[i]);
                --print("derp {}\n", copy_ar(waypoints_distance)[i]);
                i=i+1
            };
                               --print("SO MANY WAYPOINTS {}\n",|waypoints|);
           var nr_agents=0;
           for a in file.children_named("agent") {
                   nr_agents=nr_agents+{
                       match a.attribute_value("n").to_int() with
                       Just nr => nr
                       _ => {print("BADINT2!\n"); 0}
                   }
               };
               var agents= new [Agent](nr_agents);
               var i=0;
                {
                       for a in file.children_named("agent") {
                           var
                               max = int_or_0(a.attribute_value("n").to_int());
                               var x = int_or_0(a.attribute_value("xs").to_int());
                               var y = int_or_0(a.attribute_value("ys").to_int());
                               var dx_max = int_or_0(a.attribute_value("dx").to_int())/2;
                               var dy_max = int_or_0(a.attribute_value("dy").to_int())/2;
                               var agent_waypoints=new [(int,int)](|a.children_named("addway")|);
                               var dx=x-dx_max;
                               var dy=y-dy_max;
                               var j=0;
                             {
                                   for b in a.children_named("addway") {
                                       agent_waypoints[j]=waypoints[int_or_0(string_or_empty(b.attribute_value("id").substring(1,2)).to_int())-1];
                                       --print(agent_waypoints[i]);
                                       unless |agent_waypoints|>1 then {
                                           print("THIS SHOULD NEVER HAPPEN |new_agent.waypoint|={}\n", |agent_waypoints|);
                                           max = 1/0
                                       };
                                       j=j+1;
                                   };
                                    --print((x,y,dx_max,dy_max,dx,dy,max));
                                   --for each agent
                                   for unused in [0..max] {
                                       --for this to be safe, agent_waypoints need to be copied for every agent
                                       --in the future, I can make it immutable instead?
                                        if(dx>x+dx_max) then {
                                            print("out of space\n");
                                            dx=x-dx_max
                                        }
                                        else if(dy>y+dy_max) then {
                                            dy=y-dy_max;
                                            dx=dx+1-- +rand()%2
                                        }
                                        else {
                                            dy=dy+1 --+rand()%2
                                        };
                                            agents[i]=new Agent((dx,dy),copy_tr(agent_waypoints),copy_ar(waypoints_distance),i,40000);
                                            i=i+1
                                   }
                               }};
                                       agents
                                   }}}}

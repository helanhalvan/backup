module Global_funs
import Agent_passive
import XML.XML

--xmax ymax xmin ymin
def find_extreme(agents:[Agent]) : (int,int,int,int) {
    let extreme=(-10000,-10000,10000,10000);
    let i=0;
    for a in agents {
        --print("{}\n",i);
        i=i+1;
        extreme=extreme_check(a.pos(),extreme);
        for b in a.targets {
            extreme=extreme_check(b,extreme);
        }
    };
    extreme
}
def extreme_check(a:(int,int),b:(int,int,int,int) ) : (int,int,int,int) {
    match (a,b) with
        ((x,y),(xmax,ymax,xmin,ymin)) => (max(x,xmax),max(y,ymax),min(x,xmin),min(y,ymin))
}

def clock() : int {
    let x=0;
    embed void { #{x}=clock(); } end;
    x
}
def mk_Future(n : bool) : Fut bool
 embed Fut bool
   future_t *fut = future_mk(_ctx, ENCORE_PRIMITIVE);
   future_fulfil(_ctx, fut, (encore_arg_t) {.i = #{n}});
   fut;
 end
def inside(pos:(int,int),space:(int,int,int,int) ) : bool {
    match (pos,space) with
        ((x,y),(xmax,ymax,xmin,ymin)) when x>xmax or x<xmin or y>ymax or y<ymin => false
        _ => true
}
def copy_ar(arr:[int]) : [int] {
    let a2=new[int](|arr|)
        i=0
    in {
    for a in arr {
        --print("{} \n", a);
        a2[i]=a;
        i=i+1
    };
    a2}
}
def copy_tr(arr:[(int,int)]) : [(int,int)] {
        let a2=new [(int,int)](|arr|);
        let i=0;
        for a in arr {
            a2[i]=a;
            i=i+1;
        };
        a2
}
def flatten(listlist:[[(int,int)]]): [(int,int)] {
        let len=0;
        for a in listlist {
            len=len+ |a| ;
        };
        let list=new[(int,int)](len);
        let i=0;
        for a in listlist {
            for b in a {
                list[i]=b;
                i=i+1;
                --print("merging {}\n",b);
            }
        };
        unless (i==len) then print("BAD MERGE\n");
        list
    }
def max(a:int,b:int) : int {
    if(a>b) then a
    else b
    }
def min(a:int,b:int) : int {
    if(a<b) then a
    else b
    }
def int_or_0 (i:Maybe int ) : int {
        match i with
            Just nr => nr
            _ => {print("or0\n"); 0}
   }
def string_or_empty( i: Maybe String ) : String {
        match i with
            Just nr => {nr}
            _ => {print("orEmpty\n");""}
    }
def rand() : int {
    let x=0;
    embed void { #{x}=rand(); } end;
    x
}
def sleep(x:real) : void {
    embed void { sleep( #{x} ); } end
}
def rot(nr:int) : int {
    embed void { #{nr}=sqrt(#{nr}); } end;
    nr
}
def abs(a:int) : int {
    if a>0 then a else a*(-1)
}
def man_distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => abs(x1-x2)+abs(y1-y2)
         _ => { print("THIS WILL NEVER HAPPEN!"); 1/0 }
}
def distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => rot(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
         _ => { print("THIS WILL NEVER HAPPEN!"); 1/0 }
}
def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with
    ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
    _ => false
}
def parse_file(fname:String) : [Agent] {
       let
           sen = new XML_lib()
           file= new XML_node()
        in {
           match sen.file_to_xml(fname) with
           Just xml => {file=xml; --print("\n\nWORKED!\n")
                }
           Nothing => print("\n\nBADXML!\n");
        let
            xml_way = file.children_named("waypoint")
            waypoints=new [(int,int)] ( |xml_way| )
            waypoints_distance=new [int] ( |xml_way| )
            i=0
        in {
            --print(|xml_way|);
            for a in xml_way {
                waypoints[i]={
                match (a.attribute_value("x").to_int(),a.attribute_value("y").to_int()) with
                    (Just x,Just y) => (x,y)
                    _ => { print("BADINT!\n"); (0,0)}};
                waypoints_distance[i]= int_or_0(a.attribute_value("r").to_int());
                --print("derp {}\n",waypoints_distance[i]);
                --print("derp {}\n", copy_ar(waypoints_distance)[i]);
                i=i+1
            };
                               --print("SO MANY WAYPOINTS {}\n",|waypoints|);
           let nr_agents=0;
           for a in file.children_named("agent") {
                   nr_agents=nr_agents+{
                       match a.attribute_value("n").to_int() with
                       Just nr => nr
                       _ => {print("BADINT2!\n"); 0}
                   }
               };
               let agents= new [Agent](nr_agents)
                   i=0
                in {
                       for a in file.children_named("agent") {
                           let
                               max = int_or_0(a.attribute_value("n").to_int())
                               x = int_or_0(a.attribute_value("xs").to_int())
                               y = int_or_0(a.attribute_value("ys").to_int())
                               dx_max = int_or_0(a.attribute_value("dx").to_int())
                               dy_max = int_or_0(a.attribute_value("dy").to_int())
                               agent_waypoints=new [(int,int)](|a.children_named("addway")|)
                               dx=x
                               dy=y
                               j=0
                               in {
                                   for b in a.children_named("addway") {
                                       agent_waypoints[j]=waypoints[int_or_0(string_or_empty(b.attribute_value("id").substring(1,2)).to_int())-1];
                                       --print(agent_waypoints[i]);
                                       unless |agent_waypoints|>1 then {
                                           print("THIS SHOULD NEVER HAPPEN |new_agent.waypoint|={}\n", |agent_waypoints|);
                                           max = 1/0
                                       };
                                       j=j+1;
                                   };
                                    print((x,y,dx_max,dy_max,dx,dy,max));
                                   --for each agent
                                   for unused in [0..max] {
                                       --for this to be safe, agent_waypoints need to be copied for every agent
                                       --in the future, I can make it immutable instead
                                       --also distributes agents in a packed ball around (x,y) with some collisions
                                       --this should to be fixed in the future
                                        if(dx>x+dx_max) then {
                                            dx=x-dx_max
                                        }
                                        else if(dy>y+dy_max) then {
                                            dy=y-dy_max;
                                            dx=dx+rand()%4
                                        }
                                        else {
                                            dy=dy+rand()%4
                                        };
                                            --print("({})",dx);
                                            agents[i]=new Agent((dx,dy),copy_tr(agent_waypoints),copy_ar(waypoints_distance),i,40000); --THIS NUMBER DECIDES HOW LONG SIMULATION WILL RUN
                                            i=i+1
                                   }
                               }};
                               --this print checks if waypoints are added correctly
                                --print("checking\n");
                               for a in agents {
                                   if (a!=null and |a.targets|==2 and |a.targets_size|==2) then
                                       ()--print(".")
                                       else
                                           print("AGENT HAVE {} WAYPOINTS\n",|a.targets|)
                                       };
                                --while true ();
                                       agents
                                   }}}}

module Global_funs
def mk_Future(n : bool) : Fut bool
 embed Fut bool
   future_t *fut = future_mk(_ctx, ENCORE_PRIMITIVE);
   future_fulfil(_ctx, fut, (encore_arg_t) {.i = #{n}});
   fut;
 end
def inside(pos:(int,int),space:((int,int),(int,int)) ) : bool {
    match (pos,space) with
        ((x,y),((xmax,ymax),(xmin,ymin))) when x>xmax or x<xmin or y>ymax or y<ymin => false
        _ => true
}
def copy_ar(arr:[int]) : [int] {
    let a2=new[int](|arr|)
        i=0
    in {
    for a in arr {
        --print("{} \n", a);
        a2[i]=a;
        i=i+1
    };
    a2}
}
def copy_tr(arr:[(int,int)]) : [(int,int)] {
        let a2=new [(int,int)](|arr|);
        let i=0;
        for a in arr {
            a2[i]=a;
            i=i+1;
        };
        a2
}
def flatten(listlist:[[(int,int)]]): [(int,int)] {
        let len=0;
        for a in listlist {
            len=len+ |a| ;
        };
        let list=new[(int,int)](len);
        let i=0;
        for a in listlist {
            for b in a {
                list[i]=b;
                i=i+1;
            }
        };
        list
    }
def max(a:int,b:int) : int {
    if(a>b) then a
    else b
    }
def min(a:int,b:int) : int {
    if(a<b) then a
    else b
    }
def int_or_0 (i:Maybe int ) : int {
        match i with
            Just nr => nr
            _ => {print("or0\n"); 0}
   }
def string_or_empty( i: Maybe String ) : String {
        match i with
            Just nr => {nr}
            _ => {print("orEmpty\n");""}
    }
def rand() : int {
    let x=0;
    embed void { #{x}=rand(); } end;
    x
}
def sleep(x:real) : void {
    embed void { sleep( #{x} ); } end
}
def rot(nr:int) : int {
    embed void { #{nr}=sqrt(#{nr}); } end;
    nr
}
def distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => rot(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
         _ => { print("THIS WILL NEVER HAPPEN!"); 1/0 }
}
def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with
    ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
    _ => false
}

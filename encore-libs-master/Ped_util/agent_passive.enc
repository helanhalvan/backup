bundle Agent where
import Collections.HashMap
import HashCode
import Ped_util.global_funs
def copy_ar(arr:[int]) : [int] {
    let a2=new[int](|arr|)
        i=0
    in {
    for a in arr {
        --print("{} \n", a);
        a2[i]=a;
        i=i+1
    };
    a2}
}
def copy_tr(arr:[(int,int)]) : [(int,int)] {
        let a2=new [(int,int)](|arr|);
        let i=0;
        for a in arr {
            a2[i]=a;
            i=i+1;
        };
        a2
}

--data structure for holding multiple agents
--NOTE, current implementation is shit, but it's easy to change later
passive class Agent_struct {
    ss2 : HashMap<Agent>
    size : int
    def init() : void {
        this.ss2= new HashMap<Agent>();
        this.size=0
    }
    def isin(pos:(int,int)) : bool {
            let
                iterator= new HashMapIterator<Agent>(this.ss2)
                found = false
            in
            {
                while(found==false and iterator.has_next()) {
                    found = {match iterator.next() with
                                    Just item => { match (pos,item.value.pos()) with
                                                        ((x1,y1),(x2,y2)) when x1==x2 and y1==y2 => true
                                                            _ => false }}
                };
                found
            }
        }
    def add(a:Agent) : void {
            this.size=1+this.size;
            this.ss2.set(a,a)
        }
    def remove(a:Agent) : void {
            this.ss2.remove(a);
            this.size=this.size-1
        }
    def size() : int {
        this.size
    }
    def get_data() : HashMap<Agent> {
        this.ss2
    }
}
                --Abstraction for one Agent
passive class Agent : HashCode{
    hash_code : uint                --global unique id IMMUTABLE
    pos : (int,int)         --current position MUTABLE
    targets : [(int,int)]   --waypoints, a list of positions to go to IMMUTABLE
    targets_size : [int]    -- --||-- redundant, workaround var
    i : int                 --index of targets MUTABLE

    def init(in_pos:(int,int), list:[(int,int)], targets_size:[int], in_id:int) : void {
        this.pos=in_pos;
        this.i=0;
        this.targets=list;
        this.targets_size=targets_size;
        this.hash_code=in_id;
    }
    -- --returns places the agent can and want to go to
    -- --can => an agent can only go up, down, left or right
    -- --want => an agent only want to go closer to their next waypoint
    def next() : [(int,int)] {

            if |this.targets| == this.i then this.i=0;

            match (this.pos, this.targets[this.i]) with
            ((x1,y1), (x2,y2)) when distance( (x1,y1),(x2,y2) )<this.targets_size[this.i] => { this.i=this.i+1; ()}
            --((x1,y1), (x2,y2)) => {print("{}{}{}\n",(x1,y1), (x2,y2), distance((x1,y1),(x2,y2))); ()};
            _ => ();
            if |this.targets| == this.i then this.i=0;

            match (this.pos, this.targets[this.i]) with
                ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { [(x1-1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { [(x1+1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { [(x1-1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { [(x1+1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1>x2           => { [(x1-1,y1)] }
                ((x1,y1), (x2,y2)) when y1>y2           => { [(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1<x2           => { [(x1+1,y1)] }
                ((x1,y1), (x2,y2)) when y1<y2           => { [(x1,y1+1)] }
                _ => { print("THIS SHOULD NEVER HAPPEN, |targets| = {} ", |this.targets|); new [(int,int)](0) }
            }

                            --updates the current position
                            --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void
        this.pos=in_pos

                                --getter for position, used for collision detection
    def pos() : (int,int)
        this.pos

                                    --copy constructor, hopefully I won't need that one in the finnal version
    def copy() : Agent {
            let q = this.pos;
            let qq = new [(int,int)](|this.targets|);
                for i in [0..(|qq|-1)] {
                    --this change exposes that the tupple this.targets[i] get mangled somewhere
                    qq[i]=this.targets[i];
                    --qq[i]={match this.targets[i] with (x,y) => (x,y)};
                };
            let w = new Agent(q, qq, copy_ar(this.targets_size),this.hash_code);
                w.i=this.i;
                w
            }

        }

bundle Agent where
--data structure for holding multiple agents
--NOTE, current implementation is shit, but it's easy to change later
--equals metod for (int,int), while I wait for better equals
def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with
    ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
    _ => false
}
def distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => 4--rot(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
}

def rot(nr:int) : int {
    embed int { sqrt(#{nr}) } end
}
--data structure for holding multiple agents
--NOTE, current implementation is shit, but it's easy to change later
passive class Agent_struct {
    ss : [Agent]

    def init(a:[Agent]) : void {
        this.ss= new [Agent](0);
        this.add(a)
    }
    def isin(pos:(int,int)) : bool {
        let ret = false;
            for a in this.ss
            match a.pos() with
            _ when equal(pos,a.pos()) =>{ --print(" {}=={}\n",qq,a.pos);
            ret=true }
            _ => () ;
            ret
        }
    def add(a:[Agent]) : void {
        let
            sss = new [Agent]( |a| + |this.ss| )
            i=0
            in {
                for t in this.ss {
                    sss[i]=t;
                    i=i+1
                };
                for t in a {
                    sss[i]=t;
                    i=i+1
                };
                this.ss=sss
            }}
    def remove(a:Agent) : void {
        let sss = new [Agent]( |this.ss| - 1 )
            i = 0
            in{
                for t in this.ss {
                    if( not ( t == a ) ) then {
                        sss[i]=t;
                        i=i+1
                    }
                };
                this.ss=sss
            }}
    def size() : int {
        |this.ss|
    }
    --empties the data structure
    def get_data() : [Agent] {
        let sss = this.ss;
            this.ss= new [Agent](0);
            sss
        }
}
                --Abstraction for one Agent
passive class Agent {
    id : int                --global unique id IMMUTABLE, will be used to differentiate agents, at some point
    pos : (int,int)         --current position MUTABLE
    targets : [(int,int,int)]   --waypoints, a list of positions to go to IMMUTABLE, (X,Y,R), so X and Y cordinates, and R radius
    i : int                 --index of targets MUTABLE

    def init(in_pos:(int,int), list:[(int,int,int)], in_id:int) : void {
        this.pos=in_pos;
        this.i=0;
        this.targets=list;
        this.id=in_id;
    }

    -- --returns places the agent can and want to go to
    -- --can => an agent can only go up, down, left or right
    -- --want => an agent only want to go closer to their next waypoint
    def next() : [(int,int)] {
        if |this.targets| == this.i then this.i=0;

            match (this.pos, this.targets[this.i]) with
            ((x1,y1), (x2,y2,r)) when y1==y2 and x1==x2 => { this.i=this.i+1; ()}
            _ => ();
            if |this.targets| == this.i then this.i=0;

                match (this.pos, this.targets[this.i]) with
                ((x1,y1), (x2,y2,r)) when x1>x2 and y1>y2 => { [(x1-1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2,r)) when x1<x2 and y1<y2 => { [(x1+1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2,r)) when x1>x2 and y1<y2 => { [(x1-1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2,r)) when x1<x2 and y1>y2 => { [(x1+1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2,r)) when x1>x2           => { [(x1-1,y1)] }
                ((x1,y1), (x2,y2,r)) when y1>y2           => { [(x1,y1-1)] }
                ((x1,y1), (x2,y2,r)) when x1<x2           => { [(x1+1,y1)] }
                ((x1,y1), (x2,y2,r)) when y1<y2           => { [(x1,y1+1)] }
                _ => { print("THIS SHOULD NEVER HAPPEN, |targets| = {} ", |this.targets|); new [(int,int)](0) }
            }

                            --updates the current position
                            --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void
        this.pos=in_pos

                                --getter for position, used for collision detection
    def pos() : (int,int)
        this.pos

                                    --copy constructor, hopefully I won't need that one in the finnal version
    def copy() : Agent {
        let q = this.pos;
            let qq = new [(int,int,int)](|this.targets|);
                for i in [0..(|qq|-1)] {
                    --this change exposes that the tupple this.targets[i] get mangled somewhere
                    qq[i]=this.targets[i]
                    --qq[i]={match this.targets[i] with (x,y) => (x,y)};
                };
                new Agent(q, qq, this.id)
            }

        }

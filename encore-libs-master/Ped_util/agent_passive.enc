bundle Agent where
--data structure for holding multiple agents
--NOTE, current implementation is shit, but it's easy to change later
--equals metod for (int,int), while I wait for better equals
def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with
    ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
    _ => false
}
def copy_ar(arr:[int]) : [int] {
    let a2=new[int](|arr|)
        i=0
    in {
    for a in arr {
        --print("{} \n", a);
        a2[i]=a;
        i=i+1
    };
    a2}
}
def rand() : int {
    let x=0;
    embed void { #{x}=rand(); } end;
    x
}
def copy_tr(arr:[(int,int)]) : [(int,int)] {
        let a2=new [(int,int)](|arr|);
        let i=0;
        for a in arr {
            a2[i]=a;
            i=i+1;
        };
        a2
}
def distance(a:(int,int),b:(int,int)) : int {
    match (a,b) with
        ((x1,y1),(x2,y2)) => rot(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
         _ => { print("THIS WILL NEVER HAPPEN!"); 1/0 }
}
def rot(nr:int) : int {
    embed void { #{nr}=sqrt(#{nr}); } end;
    nr
}
--data structure for holding multiple agents
--NOTE, current implementation is shit, but it's easy to change later
passive class Agent_struct {
    ss : [Agent]

    def init(a:[Agent]) : void {
        this.ss= new [Agent](0);
        this.add(a)
    }
    def isin(pos:(int,int)) : bool {
        let ret = false;
            for a in this.ss
            match a.pos() with
            _ when equal(pos,a.pos()) =>{ --print(" {}=={}\n",qq,a.pos);
            ret=true }
            _ => ();
            ret
        }
    def add(a:[Agent]) : void {
        let
            sss = new [Agent]( |a| + |this.ss| )
            i=0
            in {
                for t in this.ss {
                    sss[i]=t;
                    i=i+1
                };
                for t in a {
                    sss[i]=t;
                    i=i+1
                };
                this.ss=sss
            }}
    def remove(a:Agent) : void {
        let sss = new [Agent]( |this.ss| - 1 )
            i = 0
            in{
                for t in this.ss {
                    if( not ( t.id == a.id ) ) then {
                        sss[i]=t;
                        i=i+1
                    }
                };
                this.ss=sss
            }}
    def size() : int {
        |this.ss|
    }
    --empties the data structure
    def get_data() : [Agent] {
        let sss = this.ss;
            this.ss= new [Agent](0);
            sss
        }
}
                --Abstraction for one Agent
passive class Agent {
    id : int                --global unique id IMMUTABLE
    pos : (int,int)         --current position MUTABLE
    targets : [(int,int)]   --waypoints, a list of positions to go to IMMUTABLE
    targets_size : [int]    -- --||-- redundant, workaround var
    i : int                 --index of targets MUTABLE

    def init(in_pos:(int,int), list:[(int,int)], targets_size:[int], in_id:int) : void {
        this.pos=in_pos;
        this.i=0;
        this.targets=list;
        this.targets_size=targets_size;
        this.id=in_id;
    }
    -- --returns places the agent can and want to go to
    -- --can => an agent can only go up, down, left or right
    -- --want => an agent only want to go closer to their next waypoint
    def next() : [(int,int)] {
            if |this.targets| == this.i then this.i=0;

            match (this.pos, this.targets[this.i]) with
            ((x1,y1), (x2,y2)) when distance( (x1,y1),(x2,y2) )<this.targets_size[this.i] => { this.i=this.i+1; ()}
            --((x1,y1), (x2,y2)) => {print("{}{}{}\n",(x1,y1), (x2,y2), distance((x1,y1),(x2,y2))); ()};
            _ => ();
            if |this.targets| == this.i then this.i=0;

            match (this.pos, this.targets[this.i]) with
                ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { [(x1-1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { [(x1+1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { [(x1-1,y1),(x1,y1+1)] }
                ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { [(x1+1,y1),(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1>x2           => { [(x1-1,y1)] }
                ((x1,y1), (x2,y2)) when y1>y2           => { [(x1,y1-1)] }
                ((x1,y1), (x2,y2)) when x1<x2           => { [(x1+1,y1)] }
                ((x1,y1), (x2,y2)) when y1<y2           => { [(x1,y1+1)] }
                _ => { print("THIS SHOULD NEVER HAPPEN, |targets| = {} ", |this.targets|); new [(int,int)](0) }
            }

                            --updates the current position
                            --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void
        this.pos=in_pos

                                --getter for position, used for collision detection
    def pos() : (int,int)
        this.pos

                                    --copy constructor, hopefully I won't need that one in the finnal version
    def copy() : Agent {
            let q = this.pos;
            let qq = new [(int,int)](|this.targets|);
                for i in [0..(|qq|-1)] {
                    --this change exposes that the tupple this.targets[i] get mangled somewhere
                    qq[i]=this.targets[i];
                    --qq[i]={match this.targets[i] with (x,y) => (x,y)};
                };
                new Agent(q, qq, copy_ar(this.targets_size),this.id)
            }

        }

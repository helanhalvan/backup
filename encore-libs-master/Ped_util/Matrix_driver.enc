module Matrix_driver
import Agent_passive
import Global_funs
import SDL.SDL_Main
import Ped_util.UI
--TODO FIX ALL THIS
def matrix(agents: [Agent],ui:bool) : void {
     let
         i = 0
         drivers= new [Matrix_driver]( |agents| )
         j = 0
         sdl_main = if ui then make_UI() else null : SDL_Main
         futures = new [Fut void](|agents|)
         matrix = new Lock_Matrix(agents)
     in
     {
         for a in agents {
             drivers[i]=new Matrix_driver(a,matrix);
             i=i+1;
         };
         i=0;
        (new Lock_Man())!list_loop(40000,drivers,futures,ui,sdl_main);
     }
 }
--A great manager class...
class Lock_Man {
    def init() : void { () }
    def list_loop(i:int,drivers:[Matrix_driver],futures:[Fut void],ui:bool,sdl_main:SDL_Main) : void {
                 let j = 0;
                 for a in drivers {
                     futures[j]=a.move();
                     j=j+1;
                 };
                 for a in futures {
                     get(a);
                 };
                if(ui) then {
                let positions = new [(int,int)](|drivers|);
                    for w in [0..(|drivers|-1)] {
                        positions[w]=get((drivers[w]).get_pos());
                    };
                    show(positions,sdl_main)
                };
                 if(i % 10000==0) then {
                     print("{}\n",i);
                 };
             if i>0 then this!list_loop(i-1, drivers,futures,ui,sdl_main);
     }
}
passive class Lock_Matrix {
    origin_x : int
    origin_y : int
    locks : [Lock]
    x_len : int
    def init(a:[Agent]) : void {
            match find_extreme(a) with
                (xmax,ymax,xmin,ymin) => {
                this.origin_x=xmin;
                this.origin_y=ymin;
                this.x_len=xmax-xmin;
                this.locks=new [Lock]((xmax-xmin)*(ymax-ymin));
                for a in this.locks {a=new Lock()}
            };
        }
    def aquire( pos:(int,int) ) : Fut bool {
        match pos with (x,y) => {
        (this.locks[(x-this.origin_x)+((y-this.origin_y)*this.x_len) ]).aquire()
    }}
    def release( pos:(int,int) ) : Fut void {
        match pos with (x,y) => {
        (this.locks[(x-this.origin_x)+((y-this.origin_y)*this.x_len) ]).release()
    }}
}
class Lock {
    taken : bool
    def init() : void { this.taken=false }
    def aquire() : bool {
        if this.taken then false else {
            this.taken=true;
            true
        }
    }
    def release () : void {
        this.taken=false;
    }
}
class Matrix_driver {
    agent : Agent
    matrix : Lock_Matrix
    def get_pos() : (int,int) {
        this.agent.pos;
    }
    def init(a:Agent,matrix:Lock_Matrix) : void {
        this.agent=a;
        this.matrix=matrix;
    }
    def move() : void {
        let temp = this.agent.next();
        for desired in temp {
            if ((get(this.matrix.aquire(desired)))==false) then { () } else
            {
                this.matrix.release(this.agent.pos);
                this.agent.move(desired)
            }
        };
    }
}

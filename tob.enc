class Main {
   def main() : void {
       let a = new Agent((1,1), [(1,-5)] );
       let b = new Agent((2,2), [(-5,1)] );
       let lÃ¥da = new Box([a,b]);
       {--
       while(b != Nothing) {
       match b with
           Nothing => print("done\n")
           Just w => {a.move(w[0]);
                     print("{}\n",a.pos());
                     b=a.next()}
       };
       print("{}\n",a.pos());
       --}
   }
}

class Box {
 agents : [Agent]

 def init(in_agents:[Agent]) : void
   this.agents = in_agents

 --moves all agents in the box once
 def move(): bool
   if |this.agents| == 0 then
     true
   else
     let
       j = 0
     in {
       for a in this.agents {
         match a.next() with
           Nothing => ()
           Just List => let
                          i = 0
                          cond = true
                        in
                          while(i < |List| and cond)
                            unless this.isin(List[i], this.agents) then {
                               (this.agents[j]).move(List[i]);
                               cond=false;
                            };
           j=j+1;
         } ;
         false
      }

 def isin(w:(int,int),l:[Agent]) : bool
   let
     ret = false
   in {
     for a in l
       match a.pos() with
         w => ret=true
         _ => () ;
     ret
   }
}

passive class Agent {
   id : int                --unique ID for the agent
   pos : (int,int)         --current position
   targets : [(int,int)]   --waypoints, a list of positions to go to
   i : int                 --index of targets

   def init(in_pos:(int,int), list:[(int,int)]) : void {
       this.pos=in_pos;
       this.i=0;
       this.targets=list;
   }

   -- --returns places the agent can and want to go to
   -- --can => an agent can only go up, down, left or right
   -- --want => an agent only want to go closer to their next waypoint
   def next() : Maybe [(int,int)]
     if |this.targets| == this.i then
       Nothing : Maybe([(int,int)])
     else {
       match (this.pos, this.targets[this.i]) with  
         ((x1,y1), (x2,y2)) when y1==y2 and x1==x2 => { this.i=this.i+1; this.next() }
         ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { Just [(x1-1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { Just [(x1+1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { Just [(x1-1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { Just [(x1+1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1>x2           => { Just [(x1-1,y1)] }
         ((x1,y1), (x2,y2)) when y1>y2           => { Just [(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2           => { Just [(x1+1,y1)] }
         ((x1,y1), (x2,y2)) when y1<y2           => { Just [(x1,y1+1)] }
      }
           
   --updates the current position
   --agents have no agency and check nothing when it comes to their own position
   def move(in_pos:(int,int)) : void
     this.pos=in_pos

   --getter, everything is public, but I'll pretend that everything is private, as I think that's a better practice
   def pos() : (int,int)
       this.pos
}

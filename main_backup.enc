import FileIO.IO
import XML.xml
import Ped_util.agent_passive
import SDL.SDL_Main
--import SDL.SDL_Events
class Main {
--TODO
--Add comments to explain what's going on
--Fix compile script adding 
--  -d for starting right into gdb
--  -r for compile and run
--  -t for piping errors to txt
--Split stuff up into more files, at some point

--Add a multi-threaded version of box, using many single threaded versions of box

--Add some UI
   def main() : void {

       let superbox = new Multi_box(this.parse_file("scenario.xml"));
       let x_size=0;
       let y_size=0;
       match (get(superbox.max()),get(superbox.min())) with 
                ((xmax,ymax),(xmin,ymin)) => {x_size=(xmax-xmin); y_size=(ymax-ymin);};
       {-- let sdl_main = new SDL_Main(x_size*4,y_size*4);
       get sdl_main.clearAll();
       get sdl_main.setRenderColor(new ColorRGBA(1,1,1,0));    
       get sdl_main.fillRectangle(new Rectangle(0,0,x_size*4,y_size*4));
       get sdl_main.setRenderColor(new ColorRGBA(255,255,255,0));
       get sdl_main.refresh(); --}
       let cond = true;
       while(cond) {
       {--
       get(sdl_main.clearAll()); 
       for a in get(superbox.agents())
       {
            match a.pos with 
                (x,y) => {get sdl_main.fillRectangle( new Rectangle(x*4,y*4,1,1) )}
                  _ => print("AGENT GOT NO POS!?\n")
       };
       get(sdl_main.refresh()); --}
       cond=get(superbox.move());
       }
   }
   def parse_file(fname:String) : [Agent] {
       let sen = new XML_lib();
       let file= new XML_node();

       match sen.file_to_xml("scenario.xml") with 
            Just xml => {file=xml; print("\n\nWORKED!\n")}
            Nothing => print("\n\nBADXML!\n");

       let xml_way = file.children_named("waypoint");
       let waypoints=new [(int,int)]( |xml_way| );
       let i=0;
       for a in xml_way {
           waypoints[i]={
           match (a.attribute_value("x").to_int(),a.attribute_value("y").to_int()) with 
                    (Just x,Just y) => (x,y)
                    _ => { print("BADINT!\n"); (0,0)}};
           i=i+1;
           };
       --print("SO MANY WAYPOINTS {}\n",|waypoints|);

       let nr_agents=0;
       for a in file.children_named("agent") {
            nr_agents=nr_agents+{
                match a.attribute_value("n").to_int() with
                        Just nr => nr
                        _ => {print("BADINT2!\n"); 0}
            }
       };
       let agents= new [Agent](nr_agents);
       --TODO, extact x, y, dx, dy and n from <agent> and use to create values for [agent]
       let i=0;
       for a in file.children_named("agent") {
            let max = int_or_0(a.attribute_value("n").to_int());
            let x = int_or_0(a.attribute_value("x").to_int());
            let y = int_or_0(a.attribute_value("y").to_int());
            let dx_max = int_or_0(a.attribute_value("dx").to_int());
            let dy_max = int_or_0(a.attribute_value("dy").to_int());
            let dx=0;
            let dy=0;
            let agent_waypoints=new [(int,int)](|a.children_named("addway")|);
            --print(|a.children_named("addway")|);
            let j=0;
            for b in a.children_named("addway") {
                agent_waypoints[j]=waypoints[int_or_0(string_or_empty(b.attribute_value("id").substring(1,2)).to_int())-1];
                --print(agent_waypoints[i]);
                j=j+1;
            };
            
            for derp in [0..max] {
                --for this to be safe, agent_waypoints need to be copied for every agent
                --in the future, I can make it immutable instead
                --also distributes agents in a packed ball around (x,y) with some collisions
                match (derp % 4) with 
                     0 => {agents[i]=new Agent((x+dx,y+dy),copy_tr(agent_waypoints) );
                if(dx==0) then {
                    dx=dy+1;
                    dy=0
                } else {
                    dx=dx-1;
                    dy=dy+1
                };}
                    1 => {agents[i]=new Agent((x+dx,y-dy),copy_tr(agent_waypoints));}
                    2 => {agents[i]=new Agent((x-dx,y+dy),copy_tr(agent_waypoints));}
                    3 => {agents[i]=new Agent((x-dx,y-dy),copy_tr(agent_waypoints));};
                    
                --print( (agents[i]).pos() );
                i=i+1;
            }    
       };
       agents
   }
}
def flatten(listlist:[[Agent]]) : [Agent] {
        let len=0;
        for a in listlist {
            len=len+ |a| ;        
        };
        let list= new[Agent](len);
        let i=0;
        for a in listlist {
            for b in a {
                list[i]=b;
                i=i+1;
            }        
        };
        list
    }
def copy_tr(arr:[(int,int)]) : [(int,int)] {
        let a2=new [(int,int)](|arr|);
        let i=0;        
        for a in arr {
            a2[i]=a;
            i=i+1;
        };
        a2 
   }
def max(a:int,b:int) : int {
    if(a>b) then a
    else b
    }
def min(a:int,b:int) : int {
    if(a<b) then a 
    else b
    }
def int_or_0 (i:Maybe int ) : int {
        match i with 
            Just nr => nr
            _ => {print("or0\n"); 0}
   }
def string_or_empty( i: Maybe String ) : String {
        match i with 
            Just nr => {nr}
            _ => {print("orEmpty\n");""}
    }
{--
trait Box {
    require min() : Fut (int,int)
    require max() : Fut (int,int)
    require add(a:Agent) : Fut bool
    require link(a:Box) : Fut bool
    require external_move(b:Agent,a:(int,int)) : Fut bool
}
--}

--multi threaded 2D space container
class Multi_box {
    max : (int,int)
    min : (int,int)
    top_right : Box
    bottom_right : Box
    top_left : Box
    bottom_left : Box
    def init(agents:[Agent]) : void {
        let dx=0;
        let dy=0;
        match this.find_extreme(agents) with
            (xmax,ymax,xmin,ymin) => {this.max=(xmax,ymax); 
                                      this.min=(xmin,ymin); 
                                      dx=xmax-xmin; 
                                      dy=ymax-ymin;
                                      print("{} {} {}\n",this.max,this.min,(xmax-(dx/2),ymax-(dy/2)));
                                      this.top_right=new Box(this.max,(xmax-(dx/2)+1,ymax-(dy/2)+1 ) );
                                      this.bottom_left=new Box( (xmax-(dx/2),ymax-(dy/2)),this.min);
                                      this.top_left= new Box( (xmax-(dx/2),ymax),(xmin,ymax-(dy/2)+1) );
                                      this.bottom_right=new Box( (xmax,ymax-(dy/2)),(xmax-(dx/2)+1,ymin) );
                                      print("tr {} {}\n",get(this.top_right.max()),get(this.top_right.min()) );
                                      print("bl {} {}\n",get(this.bottom_left.max()),get(this.bottom_left.min()) );
                                      print("tl {} {}\n",get(this.top_left.max()),get(this.top_left.min()) );
                                      print("br {} {}\n",get(this.bottom_right.max()),get(this.bottom_right.min()) );
                                      };
        for a in agents {
            -- adding agents into boxes
            if( not get(this.top_right.add(a))) then {
            if( not get(this.top_left.add(a))) then {
            if( not get(this.bottom_right.add(a))) then {
            if( not get(this.bottom_left.add(a))) then { () }}}
            } else {print("SOMEONE GOT NO BOX!\n");}  
        };
        let win=true;

        --LINKING BOXES, to allow them to pass agents between eachother
        win=win and get (this.top_right.link(this.top_left));
        win=win and get (this.top_right.link(this.bottom_right));     
        win=win and get (this.top_left.link(this.top_right));
        win=win and get (this.top_left.link(this.bottom_left));
        win=win and get (this.bottom_left.link(this.bottom_right));
        win=win and get (this.bottom_left.link(this.top_left));
        win=win and get (this.bottom_right.link(this.top_right));
        win=win and get (this.bottom_right.link(this.bottom_left));
        print("WIN={}\n",win);
    }
    def max() : (int,int) {this.max}
    def min() : (int,int) {this.min}
    def move () : bool {
        --Moves all the boxes in parrallel, then awaits them being done moving
        let a = this.top_right.move();
        let b = this.top_left.move();
        let c = this.bottom_right.move();
        let d = this.bottom_left.move();
        (get(a)) or (get(b)) or (get(c)) or (get(d))
    }
    def agents() : [Agent] { flatten([get(this.top_right.agents()),
                             get(this.top_left.agents()),
                             get(this.bottom_right.agents()),
                             get(this.bottom_left.agents())]) }
    def find_extreme(agents:[Agent]) : (int,int,int,int) {
        let extreme=(-10000,-10000,10000,10000);
        let i=0;
        for a in agents {
            --print("{}\n",i);
            i=i+1;
            extreme=this.extreme_check(a.pos(),extreme);
            for b in a.targets {
                extreme=this.extreme_check(b,extreme);
            }
        };
        extreme
    }
    def extreme_check(a:(int,int),b:(int,int,int,int) ) : (int,int,int,int) {
        match (a,b) with 
            ((x,y),(xmax,ymax,xmin,ymin)) => (max(x,xmax),max(y,ymax),min(x,xmin),min(y,ymin))
    }
}
--single threaded 2D space container
--contains all Agents in a given 2D region of space
--assumess cordnate system where Y is height and X is with, so increasing X means further to the right
class Box {
-- min and max are inclusive
-- max is the greatest X value and the greatest Y value box contains
-- min is the smalles X and Y values
 max : (int,int)
 min : (int,int)
 up : Box
 down : Box
 left : Box
 right : Box 
 agents : Agent_struct

def init(in_max:(int,int), in_min:(int,int) ) : void { 
    this.agents=new Agent_struct(new [Agent](0));
    this.max=in_max;
    this.min=in_min;
    }
--getters for borders
def min() : (int,int) {this.min}
def max() : (int,int) {this.max}
def agents() : [Agent] {

    let a=this.agents.get_data();
    let b = new [Agent](|a|);
    let i=0;
    for c in a {
        b[i]=c.copy();
        i=i+1
    };
    b
    }

--returns true if a is inside the box, and stores it. Otherwise returns false
--TODO, check if legal, not needed currently
def add(a:Agent) : bool{
    match (a.pos(),this.max,this.min) with 
        ((x,y),(xmax,ymax),(xmin,ymin)) when x>xmax or x<xmin or y>ymax or y<ymin => false
        _ => {this.agents.add([a]); true}
}
--if the arguements shares a border with this box, it's added to the apropriate edge and returns true
--otherwise returns false
def link(a:Box) : bool {
    let c=a.max();
    let d=a.min();
    await(c);
    await(d);
    match (this.max,this.min,get(c),get(d) ) with 
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_1+1) == x_min_2) => {this.right=a; print("right\n");true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_1+1) == y_min_2) => {this.up=a; print("up\n"); true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_2+1) == x_min_1) => {this.left=a; print("left\n");true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_2+1) == y_min_1) => {this.down=a; print("down\n");true }
        _ => { false }
    }
 --moves all agents in the box once 
 --returns true if there are some agents to move
 --otherwise false 
def move(): bool {
   match (this.agents.size() == 0) with
     true => { false }
     false => {
       for a in this.agents.get_data() {
            let desired = a.next();
            let i = 0;
            let nejbor = null:Fut bool;
            while( i < |desired| ) {
                match (desired[i],this.max,this.min) with
                    --local collision
                    _ when this.agents.isin(desired[i])  => {i=i+1; embed void { continue; } end; ()} 
                    --local move
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x<=x_max and x>=x_min and y<=y_max and y>=y_min) => { a.move((x,y)); 
                                                                                                                    print("internal move {} {}\n",x,y); 
                                                                                                                    embed void { return true; } end 
                                                                                                                  } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max and (y<y_min or y>y_max) ) or (x<x_min and (y<y_min or y>y_max) ) => { print("this should never happen, agent way off"); 1/0; () }
                    --external move
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max) => { nejbor=this.right.external_move(a.copy(),(x,y) ); () } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x<x_min) => { nejbor=this.left.external_move(a.copy(),(x,y) ); () } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (y>y_max) => { nejbor=this.up.external_move(a.copy(), (x,y) ); ()  } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (y<y_min) => { nejbor=this.down.external_move(a.copy(), (x,y) ); () };

                await(nejbor);
                match get(nejbor) with 
                    true => {this.agents.remove(a);
                             embed void { return true; } end}
                    false => {i=i+1};
                };

            match (|a.next()| == 0) with
                true => { print("dropped an agent\n"); 
                          this.agents.remove(a)}
                false => { () }
            };
          true
         }
      }

    --recives a Agent from another box
def external_move(a:Agent, pos:(int,int) ) : bool {
    if(this.agents.isin(pos)) then { false } else {
        a.move(pos);
        this.agents.add([a]);
        true   
    }
    }

}

class Main {
   def main() : void {
       let a = new Agent((1,1), [(1,-5)] );
       let b = new Agent((2,2), [(-5,1)] );
       let låda = new Box([a,b]);
       let cond = true;
       while(cond) {
            print("{}\n",a.pos());
            print("{}\n",b.pos());
            cond = get(låda.move())
       };

   }
}

class Box {
 agents : [Agent]

 def init(in_agents:[Agent]) : void
   this.agents = in_agents

 --moves all agents in the box once
 def move(): bool
   match |this.agents| == 0 with
     true => { false }
     false => {
        let j = 0;
       for a in this.agents {
         {match a.next() with
           Nothing => () -- remove that agent here!
           Just List => {let i = 0;
                         let cond = true;
                        
                          while(i < |List| and cond)
                            if ( this.isin(List[i]) ) then {
                                print("NOT MOVING to {}\n", List[i])
                                i=i+1
                            } else { 
                                print("MOVING!\n");
                                (this.agents[j]).move(List[i]);                                
                                cond=false
                            }}};
           j = j + 1
         };
         true
      }

 def isin(w:(int,int)) : bool
   let
     ret = false
   in {
     for a in this.agents
       match a.pos() with
         w =>{ print("LE POS:{}",w); ret=true }
         _ => () ;
     ret
   }
}

passive class Agent {
   id : int                --unique ID for the agent
   pos : (int,int)         --current position
   targets : [(int,int)]   --waypoints, a list of positions to go to
   i : int                 --index of targets

   def init(in_pos:(int,int), list:[(int,int)]) : void {
       this.pos=in_pos;
       this.i=0;
       this.targets=list;
   }

   -- --returns places the agent can and want to go to
   -- --can => an agent can only go up, down, left or right
   -- --want => an agent only want to go closer to their next waypoint
   def next() : Maybe [(int,int)]
     if |this.targets| == this.i then
       Nothing : Maybe([(int,int)])
     else {
       match (this.pos, this.targets[this.i]) with  
         ((x1,y1), (x2,y2)) when y1==y2 and x1==x2 => { this.i=this.i+1; this.next() }
         ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { Just [(x1-1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { Just [(x1+1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { Just [(x1-1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { Just [(x1+1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1>x2           => { Just [(x1-1,y1)] }
         ((x1,y1), (x2,y2)) when y1>y2           => { Just [(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2           => { Just [(x1+1,y1)] }
         ((x1,y1), (x2,y2)) when y1<y2           => { Just [(x1,y1+1)] }
      }
           
   --updates the current position
   --agents have no agency and check nothing when it comes to their own position
   def move(in_pos:(int,int)) : void
     this.pos=in_pos

   --getter, everything is public, but I'll pretend that everything is private, as I think that's a better practice
   def pos() : (int,int)
       this.pos
}

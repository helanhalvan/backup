class Main {
   def main() : void {
       let a = new Agent((0,1), [(5,5)] );
       let b = new Agent((1,0), [(5,5)] );
       let lada = new Box([a,b]);
       let cond = true;
       while(cond) {
            print("{}\n",a.pos());
            print("{}\n",b.pos());
            cond = get(lada.move())
       };
   }
}

def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with 
        ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
        _ => false
}

passive class Agent_Struct {
    ss : [Agent]

    def init(a:[Agent]) : void {
        this.ss= new [Agent](0);
        this.add(a)
    }

    def add(a:[Agent]) : void {
        let sss = new [Agent]( |a| + |this.ss| );
        let i=0;

            for t in this.ss {
                sss[i]=t;
                i=i+1
            };
            for t in a {
                sss[i]=t;
                i=i+1
            };

        this.ss=sss
    }
    def remove(a:Agent) : void {
        let sss = new [Agent]( |this.ss| - 1 );
        let   i = 0;        
            for t in this.ss {
                if( not ( t == a ) ) then {
                    sss[i]=t;
                    i=i+1
                }
            };
        this.ss=sss
    }
    def size() : int {
        |this.ss|
    }
    def get_data() : [Agent] {
        this.ss
    }

}

class Box {

 agents : Agent_Struct

 def init(in_agents:[Agent]) : void { 
    this.agents=new Agent_Struct(in_agents);
    }
 --moves all agents in the box once
 def move(): bool
   match (this.agents.size() == 0) with
     true => { false }
     false => {
       for a in this.agents.get_data() {
            let list = a.next();
            let i = 0;
            let cond = true;
            while( i < |list| and cond ) {
                match this.isin(list[i]) with 
                    true => {i=i+1;
                             --print("Colliding"); 
                             ()}
                    false => {
                                --print("MOVING");
                                cond=false;
                                a.move(list[i])
                                }
            };
            --print("agents");
            match (|a.next()| == 0) with
                true => { --print("dropped an agent"); 
                          this.agents.remove(a)}
                false => { () }
         };
         true
      }
    
 def isin(qq:(int,int)) : bool
   let
     ret = false
   in {
     for a in this.agents.get_data()

       match a.pos() with
         _ when equal(qq,a.pos()) =>{ --print(" {}=={}\n",qq,a.pos); 
                                        ret=true }
         _ => () ;
       ret
   }
}

passive class Agent {
   id : int                --unique ID for the agent
   pos : (int,int)         --current position
   targets : [(int,int)]   --waypoints, a list of positions to go to
   i : int                 --index of targets

   def init(in_pos:(int,int), list:[(int,int)]) : void {
       this.pos=in_pos;
       this.i=0;
       this.targets=list;
   }

   -- --returns places the agent can and want to go to
   -- --can => an agent can only go up, down, left or right
   -- --want => an agent only want to go closer to their next waypoint
   def next() : [(int,int)]
     if |this.targets| == this.i then
       new [(int,int)](0)
     else {
       match (this.pos, this.targets[this.i]) with  
         ((x1,y1), (x2,y2)) when y1==y2 and x1==x2 => { this.i=this.i+1; this.next() }
         ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { [(x1-1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { [(x1+1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { [(x1-1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { [(x1+1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1>x2           => { [(x1-1,y1)] }
         ((x1,y1), (x2,y2)) when y1>y2           => { [(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2           => { [(x1+1,y1)] }
         ((x1,y1), (x2,y2)) when y1<y2           => { [(x1,y1+1)] }
      }
           
   --updates the current position
   --agents have no agency and check nothing when it comes to their own position
   def move(in_pos:(int,int)) : void
     this.pos=in_pos

   --getter, everything is public, but I'll pretend that everything is private, as I think that's a better practice
   def pos() : (int,int)
       this.pos
}

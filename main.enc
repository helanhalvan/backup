import FileIO.IO
import XML.XML
import Ped_util.Agent_passive
import SDL.SDL_Main
import SDL.SDL_Types
import SDL.SDL_Primitives
import Ped_util.Global_funs
import Collections.HashMap
import Data.Either
class Main {
--TODO
--There is some Issue with the UI which makes main segfault

-- compile script
--  -d for starting right into gdb
--  -r for compile and run
   def main() : void {
    -- {--
       let
       superbox = new Top_box(this.parse_file("scenario.xml"))
        x_size=0
        y_size=0
        aui=true
        sdl_main = null : SDL_Main
       in {
        print("constructor-done!\n");
       --match (get(superbox.max()),get(superbox.min())) with
        --        ((xmax,ymax),(xmin,ymin)) => {x_size=(xmax-xmin); y_size=(ymax-ymin);};
       if aui then {
       sdl_main = new SDL_Main(1000,1000);
       get sdl_main.clearAll();
       get sdl_main.refresh();
       };
        --print("123456789\n");
        --superbox!hi();
        --while true { () }
       this!loop(superbox,0,aui,sdl_main);
       } --}
   }
   def loop(superbox:Top_box, tick:int, ui:bool,sdl_main:SDL_Main) : void {
       print("tick {}\n",tick);
{-
        if(ui) then {
       get(sdl_main.clearAll());
       get sdl_main.setRenderColor(new ColorRGBA(240,240,240,0));
       for a in get(superbox.agents())
            {
            match a with
                (x,y) => { --print("{} {} \n",x,y);
                            get sdl_main.fillRectangle( new Rectangle(x*4,y*4,1,1) )}
                  _ => print("AGENT GOT NO POS!?\n")
            };
       get sdl_main.setRenderColor(new ColorRGBA(0,240,0,0));
       get sdl_main.fillRectangle( new Rectangle(160*4,60*4,3,3) );
       get(sdl_main.refresh());
            };-}
--       if
        get(superbox.move());
--then
        --print("lets go to tick n+1\n");
        this!loop(superbox,tick+1,ui,sdl_main)
       }

    def parse_file(fname:String) : [Agent] {
           let
               sen = new XML_lib()
               file= new XML_node()
            in {
               match sen.file_to_xml("scenario.xml") with
               Just xml => {file=xml; print("\n\nWORKED!\n")}
               Nothing => print("\n\nBADXML!\n");
            let
                xml_way = file.children_named("waypoint")
                waypoints=new [(int,int)] ( |xml_way| )
                waypoints_distance=new [int] ( |xml_way| )
                i=0
            in {
                --print(|xml_way|);
                for a in xml_way {
                    waypoints[i]={
                    match (a.attribute_value("x").to_int(),a.attribute_value("y").to_int()) with
                        (Just x,Just y) => (x,y)
                        _ => { print("BADINT!\n"); (0,0)}};
                    waypoints_distance[i]= int_or_0(a.attribute_value("r").to_int());
                    --print("derp {}\n",waypoints_distance[i]);
                    --print("derp {}\n", copy_ar(waypoints_distance)[i]);
                    i=i+1
                };
                                   --print("SO MANY WAYPOINTS {}\n",|waypoints|);
               let nr_agents=0;
               for a in file.children_named("agent") {
                       nr_agents=nr_agents+{
                           match a.attribute_value("n").to_int() with
                           Just nr => nr
                           _ => {print("BADINT2!\n"); 0}
                       }
                   };
                   let agents= new [Agent](nr_agents)
                       i=0
                    in {
                           for a in file.children_named("agent") {
                               let
                                   max = int_or_0(a.attribute_value("n").to_int())
                                   x = int_or_0(a.attribute_value("xs").to_int())
                                   y = int_or_0(a.attribute_value("ys").to_int())
                                   dx_max = int_or_0(a.attribute_value("dx").to_int())
                                   dy_max = int_or_0(a.attribute_value("dy").to_int())
                                   agent_waypoints=new [(int,int)](|a.children_named("addway")|)
                                   dx=x
                                   dy=y
                                   j=0
                                   in {
                                       for b in a.children_named("addway") {
                                           agent_waypoints[j]=waypoints[int_or_0(string_or_empty(b.attribute_value("id").substring(1,2)).to_int())-1];
                                           --print(agent_waypoints[i]);
                                           unless |agent_waypoints|>1 then {
                                               print("THIS SHOULD NEVER HAPPEN |new_agent.waypoint|={}\n", |agent_waypoints|);
                                               max = 1/0
                                           };
                                           j=j+1;
                                       };
                                        print((x,y,dx_max,dy_max,dx,dy,max));
                                       --for each agent
                                       for unused in [0..max] {
                                           --for this to be safe, agent_waypoints need to be copied for every agent
                                           --in the future, I can make it immutable instead
                                           --also distributes agents in a packed ball around (x,y) with some collisions
                                           --this should to be fixed in the future
                                            if(dx>x+dx_max) then {
                                                dx=x-dx_max
                                            }
                                            else if(dy>y+dy_max) then {
                                                dy=y-dy_max;
                                                dx=dx+rand()%4
                                            }
                                            else {
                                                dy=dy+rand()%4
                                            };
                                                --print("({})",dx);
                                                agents[i]=new Agent((dx,dy),copy_tr(agent_waypoints),copy_ar(waypoints_distance),i,40000); --THIS NUMBER DECIDES HOW LONG SIMULATION WILL RUN
                                                i=i+1
                                       }
                                   }};
                                   --this print checks if waypoints are added correctly
                                    print("checking\n");
                                   for a in agents {
                                       if (a!=null and |a.targets|==2 and |a.targets_size|==2) then
                                           ()--print(".")
                                           else
                                               print("AGENT HAVE {} WAYPOINTS\n",|a.targets|)
                                           };
                                    --while true ();
                                           agents
                                       }}}}
}
{--
trait Box {
    require min() : Fut (int,int)
    require max() : Fut (int,int)
    require add(a:Agent) : Fut bool
    require link(a:Box) : Fut bool
    require external_move(b:Agent,a:(int,int)) : Fut bool
}
--}

--multi threaded 2D space container
class Top_box {
    --max x and y cords
    max : (int,int)
    --min x and y cords
    min : (int,int)
    implementation : Box

    --TODO, adding a toplevel field where I can send agents that go out of bounds
    --currently I just create a massive box, and have agents in it never move
    toplevel : Box

    def init(agents:[Agent]) : void {
        let
            dx=0
            dy=0
        in {
        --find global xmax, xmin, and ymin, use to create boundries for the 2D space.
        --looks at both starting positions and waypoints
        match this.find_extreme(agents) with
            (xmax,ymax,xmin,ymin) => {this.max=(xmax,ymax);
                                      this.min=(xmin,ymin);
                                      --print("top-setup-toplevel\n");
                                      this.toplevel=new Box( (100000,100000), (-100000,-100000), Nothing : Maybe Box, -666 );
                                      --print("top-setup-imp\n");
                                      this.implementation=new Box(this.max,this.min,Just this.toplevel, 3 );
                                      --print("top-imp-done\n");
                                      };
        for a in agents {
            --print(".");
            this.implementation.add(a)
        }};
    print("top-setup-done\n")
    }
    --get corners of box
    def max() : (int,int) {this.max}
    def min() : (int,int) {this.min}
    --moves all internal agents on step, returns true if any agents tried to move
    def move () : bool {
            if (get(this.implementation.move()))>0 then true else false
        }
    def agents() : [(int,int)] { this.implementation.agents() }

    def find_extreme(agents:[Agent]) : (int,int,int,int) {
        let extreme=(-10000,-10000,10000,10000);
        let i=0;
        for a in agents {
            --print("{}\n",i);
            i=i+1;
            extreme=this.extreme_check(a.pos(),extreme);
            for b in a.targets {
                extreme=this.extreme_check(b,extreme);
            }
        };
        extreme
    }
    def extreme_check(a:(int,int),b:(int,int,int,int) ) : (int,int,int,int) {
        match (a,b) with
            ((x,y),(xmax,ymax,xmin,ymin)) => (max(x,xmax),max(y,ymax),min(x,xmin),min(y,ymin))
    }
    --makes all box instances print 0 to stdout, only for troubleshooting
    def hi() : void {print("zeroes\n");this.implementation.hi()}
}
--EITHER
-- new Left<LEFTTYPE,RIGHTTYPE>(OBJ)
-- new RIGHT<LEFTTYPE,RIGHTTYPE>(OBJ)

passive class Box {
    toplevel : Box --immutable
    single : Single_Box --immutable
    multi : [Box]  --immutable
    allways_single : bool --immutable
    max : (int,int) --immutable
    min : (int,int) --immutable
    level : int -- immutable, 0 is the basement where all the workers are
    def max() : (int,int) {this.max}
    def min() : (int,int) {this.min}
    def hi() : void {print("0\n"); for a in this.multi a.hi()}
    --SETUP FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++
    --TOPLEVEL IS AN OPTIONAL ARGUEMNT FOR SOMEWHERE TO SEND AGENTS THAT GO OUT OF BOUNDS
    --IF NO TOPLEVEL IS PRESENT AND A AGENT GOES OUT OF BONDS BAD THINGS WILL HAPPEN
    def init(in_max:(int,int), in_min:(int,int), toplevel:Maybe Box, levels_left:int) : void {
        this.max=in_max;
        this.min=in_min;
        this.level=levels_left;
        this.toplevel= { match toplevel with Just box => {box} _ => {this} };
        if(levels_left>0) then {
            match (in_max,in_min) with
                ((xmax,ymax),(xmin,ymin)) => {
            let
                dx=xmax-xmin
                dy=ymax-ymin
                in {
                  dx=dx/2;
                  dy=dy/2;
                  this.multi = new [Box](4);
                  this.multi[0]=new Box( this.max,(xmax-dx+1,ymax-dy+1 ), Just this,levels_left-1);
                  this.multi[1]=new Box( (xmax-dx,ymax-dy),this.min,      Just this,levels_left-1);
                  this.multi[2]=new Box( (xmax-dx,ymax),(xmin,ymax-dy+1), Just this,levels_left-1);
                  this.multi[3]=new Box( (xmax,ymax-dy),(xmax-dx+1,ymin), Just this,levels_left-1);
                  this.allways_single=false;
        }}}
        else { this.allways_single=true; this.multi= new [Box](0) };
        this.single=new Single_Box(in_max,in_min,this.toplevel)
    }
    --single_box can link to box, it's one way
{-
    def link(a:Box) : void {
    let c=a.max;
    let d=a.min;
    match (this.max,this.min,c,d ) with
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_1+1) == x_min_2) or ((y_max_1+1) == y_min_2) or ((x_max_2+1) == x_min_1) or ((y_max_2+1) == y_min_1)
        => { for item in this.multi { item.link(a) }; --works every time as this.multi can have length 0
             this.single.link(a);
             ()}
        _ => ()
    }
-}
    def add(a:Agent) : bool {
        --print("adding {}\n",a.pos());
        --print("{}{}\n",this.max,this.min);
        if not inside(a.pos(),(this.max,this.min)) then false else {
            if(this.allways_single) then {
                --print("SINGLE FOUND\n");
                --print("{} {} \n",this.single_now,this.single);
                this.single.add(a); ()
            } else {
                for item in this.multi {
                --print("{} {}\n",a,item);
                --print("add multiplying {}\n",a.pos());
                item.add(a.copy())
            }};
            true
    }}
        --this fun will be massive bottleneck, however only when UI is on
    def agents() : [(int,int)] {
        if(this.allways_single) then { get(this.single.agents())
        } else {
            let
                a = ((this.multi)[0]).agents()
                b = ((this.multi)[1]).agents()
                c = ((this.multi)[2]).agents()
                d = ((this.multi)[3]).agents()
            in {
            flatten([a,b,c,d])
        }}
    }
    --check if within bounds, else send to toplevel
    def external_move(a:Agent, pos:(int,int)) : Fut bool {
        if( not inside(pos,(this.max,this.min)) ) then {
            if(this==this.toplevel) then {
                print("GOING TO HIGH! SHOULD NEVER HAPPEN\n");
                1/0;
                mk_Future(false)}
            else { this.toplevel.external_move(a,pos) }}
        else {
        if (this.allways_single) then this.single.external_move(a,pos) else {
            let ret = mk_Future(false);
            for item in this.multi {
                if inside(pos, (item.max, item.min)) then {
                    ret=item.external_move(a,pos);
                    --embed Fut bool { return #{ret} } end
                    }
                };
            ret
            --print("CHILDREN DON'T COVER ALL GROUND"); 1/0; mk_Future(false)
        }}
    }
    def move() : Fut int {
        if(this.allways_single) then this.single.move() else {
        let
            lamb = \ (nr:int) -> {nr}
        in {
        for index in [0..|this.multi|-2] {
            lamb = \ (x:int)-> { x+get(((this.multi[index]).move()) ~~>lamb ) };
            };
         (((this.multi)[ |this.multi|-1 ]).move()) ~~> lamb
    }}}
}
--single threaded 2D space container
--contains all Agents in a given 2D region of space
--assumess cordnate system where Y is height and X is with, so increasing X means further to the right
class Single_Box {
-- min and max are inclusive
-- max is the greatest X value and the greatest Y value box contains
-- min is the smalles X and Y values
 max : (int,int)
 min : (int,int)
 up : Box
 down : Box
 left : Box
 right : Box
 agents : Agent_struct

def init(in_max:(int,int), in_min:(int,int),toplevel:Box ) : void {
    this.agents=new Agent_struct();
    this.max=in_max;
    this.min=in_min;
    --print("LEVEL: {}\n",toplevel.level);
    this.up=toplevel;
    this.down=toplevel;
    this.left=toplevel;
    this.right=toplevel;
    }
--getters for borders
def min() : (int,int) { this.min }
def max() : (int,int) { this.max }
def agents() : [(int,int)] {
    let
     b = new [(int,int)](this.agents.size())
     hashmap = this.agents.get_data()
     a = new HashMapIterator<Agent>(hashmap)
     i = 0
    in {
    while a.has_next() {
        b[i]=match a.next() with Just entry => entry.value.pos();
        i=i+1
    };
    if i < this.agents.size() then
        {
    let c = new [(int,int)](i);
    for index in [0..i] {
        c[index]=b[index];
    };
        c
    }
    else b
    }}

def add(a:Agent) : void { this.agents.add(a) }
--if the arguements shares a border with this box, it's added to the apropriate edge and returns true
--otherwise returns false
--unused
{-
def link(a:Box) : bool {
    let c=a.max();
    let d=a.min();
    match (this.max,this.min,c,d ) with
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_1+1) == x_min_2) => {this.right=a;print("right\n");true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_1+1) == y_min_2) => {this.up=a;   print("up\n"); true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_2+1) == x_min_1) => {this.left=a; print("left\n");true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_2+1) == y_min_1) => {this.down=a; print("down\n");true }
        _ => { false }
    }
-}
 --moves all agents in the box once
 --returns true if there are some agents to move
 --otherwise false
{--
def move(n:int, callback: bool -> void) : void {
        if n==1 then callback(this.internal_move()) else {
            this!move(n-1,callback)
        }
    } --}
def move(): int {
        --n=n-1;
        let iterator = new HashMapIterator<Agent>(this.agents.get_data());
       while iterator.has_next() {
            let
                a = {match iterator.next() with Just entry => {entry.value}}
                desired = a.next()
                i = 0
                nejbor = null:Fut bool
                stillhere = true
            in {
            if |desired| == 0 then stillhere=false; --happens if TTL runs out
            while( i < |desired| and stillhere == true) {
                --print(desired[i]);
                match (desired[i],this.max,this.min) with
                    --local collision
                    _ when this.agents.isin(desired[i])  => {i=i+1; embed void { continue; } end; ()}
                    --local move
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x<=x_max and x>=x_min and y<=y_max and y>=y_min) => { a.move((x,y));
                                                                                                                    embed void { break; } end
                                                                                                                  }
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max and (y<y_min or y>y_max) ) or (x<x_min and (y<y_min or y>y_max) ) => { print("this should never happen, agent way off"); 1/0; () }
                    --external move
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max) => { nejbor=this.right.external_move(a.copy(),(x,y) ); () }
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x<x_min) => { nejbor=this.left.external_move(a.copy(),(x,y) ); () }
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (y>y_max) => { nejbor=this.up.external_move(a.copy(),(x,y) ); ()  }
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (y<y_min) => { nejbor=this.down.external_move(a.copy(),(x,y) ); () };

                await(nejbor);
                if get(nejbor) then {
                    stillhere=false;
                    --print("ACCESS DENIED {} ##########################\n", a.i);
                    embed void { break; } end
                }
                else {
                    stillhere=true;
                    i=i+1
                }};
            if (stillhere == false) then {
                    this.agents.remove(a);
                }
            }};
        this.agents.size()
        --if n==0 then true else this.move(n)
    }
    --recives a Agent from another box
def external_move(a:Agent, pos:(int,int) ) : bool {
    if(this.agents.isin(pos)) then { false } else {
        a.move(pos);
        this.agents.add(a);
        --print("SOMETHING WILL HAPPEN NOW\n");
        true
        }
    }
}

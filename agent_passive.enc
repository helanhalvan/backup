class Main {
--TODO
--Add comments to explain what's going on
--Fix compile script adding 
--  -d for starting right into gdb
--  -r for compile and run
--  -t for piping errors to txt
--Split stuff up into more files, at some point

--Add a multi-threaded version of box, using many single threaded versions of box

--Add some UI
   def main() : void {

       let t = null : Fut bool;
       let t2 = null : Fut bool;
       
       let lada = new Box((10,10),(-10,-10) );
       let lada2 = new Box((20,10),(11,-10) );
       let cond = true;

       lada.add(new Agent((1,0), [(15,5)]));
       get(lada.link(lada2));
       get(lada2.link(lada));
       while(cond) {
            t = lada.move();
            t2 = lada2.move(); 
            cond = ( (get(t) ) or (get(t2)) );
       };
   }
}
--quals metod for (int,int), while I wait for better equals
def equal(a:(int,int),b:(int,int)) : bool {
    match (a,b) with 
        ((a1,a2),(b1,b2)) when (a1==b1 and a2==b2) => true
        _ => false
}

--single threaded 2D space container
--contains all Agents in a given 2D region of space
--assumess cordnate system where Y is height and X is with, so increasing X means further to the right
class Box {
-- min and max are inclusive
-- max is the greatest X value and the greatest Y value box contains
-- min is the smalles X and Y values
 max : (int,int)
 min : (int,int)
 up : Box
 down : Box
 left : Box
 right : Box 
 agents : Agent_struct

def init(in_max:(int,int), in_min:(int,int) ) : void { 
    this.agents=new Agent_struct(new [Agent](0));
    this.max=in_max;
    this.min=in_min;
    }
--getters for borders
def min() : (int,int) {this.min}
def max() : (int,int) {this.max}

--returns true if a is inside the box, and stores it. Otherwise returns false
--TODO, check if legal, not needed currently
def add(a:Agent) : bool{ 
    this.agents.add([a]);
    true
}
--if the arguements shares a border with this box, it's added to the apropriate edge and returns true
--otherwise returns false
def link(a:Box) : bool {
    let c=a.max();
    let d=a.min();
    await(c);
    await(d);
    match (this.max,this.min,get(c),get(d) ) with 
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_1+1) == x_min_2) => {this.right=a; print("right\n");true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_1+1) == y_min_2) => {this.up=a; print("up\n"); true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((x_max_2+1) == x_min_1) => {this.left=a; print("left\n");true }
        ( (x_max_1,y_max_1),(x_min_1,y_min_1),(x_max_2,y_max_2),(x_min_2,y_min_2) ) when ((y_max_2+1) == x_min_1) => {this.down=a; print("down\n");true }
        _ => { false }
    }
 --moves all agents in the box once 
 --returns true if there are some agents to move
 --otherwise false 
def move(): bool {
   match (this.agents.size() == 0) with
     true => { false }
     false => {
       for a in this.agents.get_data() {
            let desired = a.next();
            let i = 0;
            let nejbor = null:Fut bool;
            while( i < |desired| ) {
                match (desired[i],this.max,this.min) with
                    --local collision
                    _ when this.agents.isin(desired[i])  => {i=i+1; embed void { continue; } end; ()} 
                    --local move
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x<=x_max and x>=x_min and y<=y_max and y>=y_min) => { a.move((x,y)); 
                                                                                                                    print("internal move {} {}\n",x,y); 
                                                                                                                    embed void { return true; } end 
                                                                                                                  } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max and (y<y_min or y>y_max) ) or (x<x_min and (y<y_min or y>y_max) ) => { print("this should never happen, agent way off"); 1/0; () }
                    --external move
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x>x_max) => { nejbor=this.right.external_move(a,(x,y) ); () } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (x<x_min) => { nejbor=this.left.external_move(a,(x,y) ); () } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (y>y_max) => { nejbor=this.up.external_move(a, (x,y) ); ()  } 
                    ((x,y),(x_max,y_max),(x_min,y_min)) when (y<y_min) => { nejbor=this.down.external_move(a, (x,y) ); () };

                await(nejbor);
                match get(nejbor) with 
                    true => {this.agents.remove(a);
                             i=100}
                    false => {i=i+1};
                };

            match (|a.next()| == 0) with
                true => { print("dropped an agent\n"); 
                          this.agents.remove(a)}
                false => { () }
            };
          true
         }
      }

    --recives a Agent from another box
def external_move(a:Agent, pos:(int,int) ) : bool {
    if(this.agents.isin(pos)) then { false } else {
        a.move(pos);
        this.agents.add([a]);
        true   
    }
    }

}

--data structure for holding multiple agents
--NOTE, current implementation is shit, but it's easy to change later
passive class Agent_struct {
    ss : [Agent]

    def init(a:[Agent]) : void {
        this.ss= new [Agent](0);
        this.add(a)
    }
    def isin(pos:(int,int)) : bool {
    let ret = false;
     for a in this.ss

       match a.pos() with
         _ when equal(pos,a.pos()) =>{ --print(" {}=={}\n",qq,a.pos); 
                                        ret=true }
         _ => () ;
       ret
    }
    def add(a:[Agent]) : void {
        let sss = new [Agent]( |a| + |this.ss| );
        let i=0;

            for t in this.ss {
                sss[i]=t;
                i=i+1
            };
            for t in a {
                sss[i]=t;
                i=i+1
            };
        this.ss=sss
    }
    def remove(a:Agent) : void {
        let sss = new [Agent]( |this.ss| - 1 );
        let   i = 0;        
            for t in this.ss {
                if( not ( t == a ) ) then {
                    sss[i]=t;
                    i=i+1
                }
            };
        this.ss=sss
    }
    def size() : int {
        |this.ss|
    }

    def get_data() : [Agent] {
        this.ss
    }
}
--Abstraction for one Agent
passive class Agent {
   pos : (int,int)         --current position MUTABLE
   targets : [(int,int)]   --waypoints, a list of positions to go to IMMUTABLE
   i : int                 --index of targets MUTABLE

   def init(in_pos:(int,int), list:[(int,int)]) : void {
       this.pos=in_pos;
       this.i=0;
       this.targets=list;
   }

   -- --returns places the agent can and want to go to
   -- --can => an agent can only go up, down, left or right
   -- --want => an agent only want to go closer to their next waypoint
   def next() : [(int,int)]
     if |this.targets| == this.i then
       new [(int,int)](0)
     else {
       match (this.pos, this.targets[this.i]) with  
         ((x1,y1), (x2,y2)) when y1==y2 and x1==x2 => { this.i=this.i+1; this.next() }
         ((x1,y1), (x2,y2)) when x1>x2 and y1>y2 => { [(x1-1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1<y2 => { [(x1+1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1>x2 and y1<y2 => { [(x1-1,y1),(x1,y1+1)] }
         ((x1,y1), (x2,y2)) when x1<x2 and y1>y2 => { [(x1+1,y1),(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1>x2           => { [(x1-1,y1)] }
         ((x1,y1), (x2,y2)) when y1>y2           => { [(x1,y1-1)] }
         ((x1,y1), (x2,y2)) when x1<x2           => { [(x1+1,y1)] }
         ((x1,y1), (x2,y2)) when y1<y2           => { [(x1,y1+1)] }
      }
           
   --updates the current position
   --agents have no agency and check nothing when it comes to their own position
   def move(in_pos:(int,int)) : void
     this.pos=in_pos

   --getter for position, used for collision detection
   def pos() : (int,int)
       this.pos

   --copy constructor, hopefully I won't need that one
 {--  def copy() : Agent {
    print("COPYING {}\n", |this.targets| - this.i);
  embed void fflush(stdout); end;
    let q = this.pos; --{match this.pos with (x,y) => (x,y)};
    let qq = new [(int,int)](|this.targets| - this.i);
    --let i = 0;
    for i in [0..|qq|] {
        qq[i]=this.targets[i];--(match this.targets[i] with (x,y) => (x,y));
        --i=i+1
    };
    new Agent(q, qq)
   } 
  --}
}

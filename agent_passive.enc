class Main {
    def main() : void {
        let b = new Agent((1,1), [(1,-5)]); 
        
    }
}
passive class Agent {
    id : int                --unique ID for the agent
    pos : (int,int)         --current position
    targets : [(int,int)]   --waypoints, a list of positions to go to
    i : int                 --index of targets
    def init(in_pos:(int,int), in_t:[(int,int)]) : void {
        this.pos=in_pos;
        this.targets=in_t;
        this.i=0;
    }
    --returns places the agent can and want to go to
    --can => an agent can only go up, down, left or right
    --want => an agent only want to go closer to their next waypoint
    def next() : [(int,int)] {
        while this.targets[this.i]==this.pos {
            this.i=this.i+1;
        };
        -- this is so much nicer then equivalent C!
        match (this.pos,this.targets[this.i]) with
              ( (x1,y1),(x2,y2) ) when (x1>x2 and y1>y2) => [(x1-1,y1),(x1,y1-1)]
              ( (x1,y1),(x2,y2) ) when (x1<x2 and y1<y2) => [(x1+1,y1),(x1,y1+1)]

              ( (x1,y1),(x2,y2) ) when (x1>x2 and y1<y2) => [(x1-1,y1),(x1,y1+1)]
              ( (x1,y1),(x2,y2) ) when (x1<x2 and y1>y2) => [(x1+1,y1),(x1,y1-1)]

              ( (x1,y1),(x2,y2) ) when (x1>x2) => [(x1-1,y1)]
              ( (x1,y1),(x2,y2) ) when (y1>y2) => [(x1,y1-1)]
              ( (x1,y1),(x2,y2) ) when (x1<x2) => [(x1+1,y1)]
              ( (x1,y1),(x2,y2) ) when (y1<y2) => [(x1,y1+1)]
    }
    --updates the current position
    --agents have no agency and check nothing when it comes to their own position
    def move(in_pos:(int,int)) : void {
        this.pos=in_pos;
    }
}

